[
  {
    "objectID": "CLI/pl.html",
    "href": "CLI/pl.html",
    "title": "pl",
    "section": "",
    "text": "source\n\nde_emi\n\n de_emi (coh:str, ph:str, emi_quality:str, ref:int=0,\n         point_chunk_size:int=None, log:str=None,\n         plot_emi_quality:bool=False, vmin:int=1.0, vmax:int=1.3,\n         ds_idx:str=None, shape:tuple=None, emi_quality_fig:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\npoint_chunk_size\nint\nNone\nparallel processing point chunk size\n\n\nlog\nstr\nNone\nlog\n\n\nplot_emi_quality\nbool\nFalse\nif plot the emi quality\n\n\nvmin\nint\n1.0\nmin value of emi quality to plot\n\n\nvmax\nint\n1.3\nmax value of emi quality to plot\n\n\nds_idx\nstr\nNone\nindex of ds\n\n\nshape\ntuple\nNone\nshape of one image\n\n\nemi_quality_fig\nstr\nNone\npath to save the emi quality plot, optional. Default, no saving\n\n\n\n\nds_can_coh = './co/ds_can_coh.zarr'\nds_can_ph = './ph/ds_can_ph.zarr'\nds_can_idx = './shp/ds_can_idx.zarr' # only for plot\nds_can_emi_quality = './pl/ds_can_emi_quality.zarr'\nref = 0\npoint_chunk_size = None\nvmin=1.0\nvmax=1.3\nlog = 'pl/de_emi.log'\nemi_quality_fig = './pl/emi_quality.png'\n\n\nshape = zarr.open('./raw/rslc.zarr/','r').shape[:2]\n\n\nde_emi(ds_can_coh,ds_can_ph,ds_can_emi_quality,ref=ref,point_chunk_size=point_chunk_size,log=log,plot_emi_quality=True,\n       vmin=vmin,vmax=vmax,ds_idx=ds_can_idx,shape=shape,emi_quality_fig=emi_quality_fig)\n\n2023-10-13 21:36:34 - de_emi - INFO - fetching args:\n2023-10-13 21:36:34 - de_emi - INFO - coh = './co/ds_can_coh.zarr'\n2023-10-13 21:36:34 - de_emi - INFO - ph = './ph/ds_can_ph.zarr'\n2023-10-13 21:36:34 - de_emi - INFO - emi_quality = './pl/ds_can_emi_quality.zarr'\n2023-10-13 21:36:34 - de_emi - INFO - ref = 0\n2023-10-13 21:36:34 - de_emi - INFO - point_chunk_size = None\n2023-10-13 21:36:34 - de_emi - INFO - log = 'pl/de_emi.log'\n2023-10-13 21:36:34 - de_emi - INFO - plot_emi_quality = True\n2023-10-13 21:36:34 - de_emi - INFO - vmin = 1.0\n2023-10-13 21:36:34 - de_emi - INFO - vmax = 1.3\n2023-10-13 21:36:34 - de_emi - INFO - ds_idx = './shp/ds_can_idx.zarr'\n2023-10-13 21:36:34 - de_emi - INFO - shape = (2500, 1834)\n2023-10-13 21:36:34 - de_emi - INFO - emi_quality_fig = './pl/emi_quality.png'\n2023-10-13 21:36:34 - de_emi - INFO - fetching args done.\n2023-10-13 21:36:34 - de_emi - INFO - ./co/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-10-13 21:36:34 - de_emi - INFO - ./co/ds_can_coh.zarr zarray chunks: (1000, 17, 17)\n2023-10-13 21:36:34 - de_emi - INFO - ./co/ds_can_coh.zarr zarray dtype: complex64\n2023-10-13 21:36:34 - de_emi - INFO - using default parallel processing azimuth chunk size from coh dataset.\n2023-10-13 21:36:34 - de_emi - INFO - parallel processing point chunk size: 1000\n2023-10-13 21:36:34 - de_emi - INFO - starting dask CUDA local cluster.\n2023-10-13 21:36:42 - de_emi - INFO - dask local CUDA cluster started.\n2023-10-13 21:36:42 - de_emi - INFO - coh dask array shape: (740397, 17, 17)\n2023-10-13 21:36:42 - de_emi - INFO - coh dask array chunksize: (1000, 17, 17)\n2023-10-13 21:36:42 - de_emi - INFO - coh dask array dtype: complex64\n2023-10-13 21:36:42 - de_emi - INFO - phase linking with EMI.\n2023-10-13 21:36:44 - de_emi - INFO - got ph and emi_quality.\n2023-10-13 21:36:44 - de_emi - INFO - ph dask array shape: (740397, 17)\n2023-10-13 21:36:44 - de_emi - INFO - ph dask array chunksize: (1000, 17)\n2023-10-13 21:36:44 - de_emi - INFO - ph dask array dtype: complex64\n2023-10-13 21:36:44 - de_emi - INFO - emi_quality dask array shape: (740397,)\n2023-10-13 21:36:44 - de_emi - INFO - emi_quality dask array chunksize: (1000,)\n2023-10-13 21:36:44 - de_emi - INFO - emi_quality dask array dtype: float32\n2023-10-13 21:36:44 - de_emi - INFO - saving ph and emi_quality.\n2023-10-13 21:36:44 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:36:50 - de_emi - INFO - computing finished.\n2023-10-13 21:36:52 - de_emi - INFO - dask cluster closed.\n2023-10-13 21:36:52 - de_emi - INFO - plotting emi_quality.\n2023-10-13 21:36:52 - de_emi - INFO - reading is_ds bool array\n2023-10-13 21:36:53 - de_emi - INFO - converting emi_quality from point cloud to raster.\n2023-10-13 21:36:53 - de_emi - INFO - saving figure\n2023-10-13 21:36:53 - de_emi - INFO - showing\n\n\n2023-10-13 21:36:36,515 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,515 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,524 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,524 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,528 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,528 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,532 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,532 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,533 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,534 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,534 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,534 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,535 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,535 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:36:36,542 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:36:36,542 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize"
  },
  {
    "objectID": "CLI/pc.html",
    "href": "CLI/pc.html",
    "title": "pc",
    "section": "",
    "text": "source\n\nde_ras2pc\n\n de_ras2pc (idx:str, ras:str|list, pc:str|list, pc_chunk_size:int=None,\n            hd_chunk_size:tuple|list=None, log:str=None)\n\nConvert raster data to point cloud data\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud index\n\n\nras\nstr | list\n\npath (in string) or list of path for raster data\n\n\npc\nstr | list\n\noutput, path (in string) or list of path for point cloud data\n\n\npc_chunk_size\nint\nNone\noutput point chunk size, same as input idx by default\n\n\nhd_chunk_size\ntuple | list\nNone\noutput high dimension chunk size, tuple or list of tuple, same as input raster data by default\n\n\nlog\nstr\nNone\nlog file. Default: no log file\n\n\n\n\n!de_ras2pc -h\n\nusage: de_ras2pc [-h] --ras RAS [RAS ...] --pc PC [PC ...]\n                 [--pc_chunk_size PC_CHUNK_SIZE]\n                 [--hd_chunk_size HD_CHUNK_SIZE [HD_CHUNK_SIZE ...]] [--log LOG]\n                 idx\n\nConvert raster data to point cloud data\n\npositional arguments:\n  idx                                   point cloud index\n\noptions:\n  -h, --help                            show this help message and exit\n  --ras RAS [RAS ...]                   one or more path for raster data\n  --pc PC [PC ...]                      output, one or more path for point cloud\n                                        data\n  --pc_chunk_size PC_CHUNK_SIZE         output point chunk size, same as input\n                                        idx by default\n  --hd_chunk_size HD_CHUNK_SIZE [HD_CHUNK_SIZE ...]\n                                        output high dimension chunk size, each\n                                        size should be wrapped in quotation\n                                        marks and size in each dimension are\n                                        seperated with \",\", same as input raster\n                                        data by default\n  --log LOG                             log file. Default: no log file\n\n\nUsage:\n\nras_data1 = np.random.rand(100,100).astype(np.float32)\nras_data2 = np.random.rand(100,100,3).astype(np.float32)+1j*np.random.rand(100,100,3).astype(np.float32)\n\nidx = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx.sort()\nidx = np.stack(np.unravel_index(idx,shape=(100,100))).astype(np.int32)\n\npc_data1 = ras_data1[idx[0],idx[1]]\npc_data2 = ras_data2[idx[0],idx[1]]\n\nidx_zarr = zarr.open('pc/idx.zarr','w',shape=idx.shape,dtype=idx.dtype,chunks=(2,200))\nras_zarr1 = zarr.open('pc/ras1.zarr','w',shape=ras_data1.shape,dtype=ras_data1.dtype,chunks=(20,100))\nras_zarr2 = zarr.open('pc/ras2.zarr','w',shape=ras_data2.shape,dtype=ras_data2.dtype,chunks=(20,100,1))\nidx_zarr[:] = idx\nras_zarr1[:] = ras_data1\nras_zarr2[:] = ras_data2\n\n\nde_ras2pc('pc/idx.zarr','pc/ras1.zarr','pc/pc1.zarr')\npc_zarr1 = zarr.open('pc/pc1.zarr','r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\n\n!de_ras2pc pc/idx.zarr --ras pc/ras2.zarr --pc pc/pc2.zarr --hd_chunk_size '1'\npc_zarr2 = zarr.open('pc/pc2.zarr','r')\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\nde_ras2pc('pc/idx.zarr',ras=['pc/ras1.zarr','pc/ras2.zarr'],pc=['pc/pc1.zarr','pc/pc2.zarr'],hd_chunk_size=[(),(1,)])\npc_zarr1 = zarr.open('pc/pc1.zarr','r')\npc_zarr2 = zarr.open('pc/pc2.zarr','r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\n!de_ras2pc pc/idx.zarr --ras pc/ras1.zarr pc/ras2.zarr --pc pc/pc1.zarr pc/pc2.zarr --hd_chunk_size '' '1'\npc_zarr1 = zarr.open('pc/pc1.zarr','r')\npc_zarr2 = zarr.open('pc/pc2.zarr','r')\nnp.testing.assert_array_equal(pc_data1,pc_zarr1[:])\nnp.testing.assert_array_equal(pc_data2,pc_zarr2[:])\n\n2023-10-14 22:42:27 - de_ras2pc - INFO - fetching args:\n2023-10-14 22:42:27 - de_ras2pc - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:27 - de_ras2pc - INFO - ras = 'pc/ras1.zarr'\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc = 'pc/pc1.zarr'\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc_chunk_size = None\n2023-10-14 22:42:27 - de_ras2pc - INFO - hd_chunk_size = None\n2023-10-14 22:42:27 - de_ras2pc - INFO - log = None\n2023-10-14 22:42:27 - de_ras2pc - INFO - fetching args done.\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:42:27 - de_ras2pc - INFO - no input pc_chunk_size, use pc_chunk_size as input idx\n2023-10-14 22:42:27 - de_ras2pc - INFO - pc_chunk_size: 200\n2023-10-14 22:42:27 - de_ras2pc - INFO - loading idx into memory.\n2023-10-14 22:42:27 - de_ras2pc - INFO - starting dask local cluster.\n2023-10-14 22:42:29 - de_ras2pc - INFO - dask local cluster started.\n2023-10-14 22:42:29 - de_ras2pc - INFO - start to slice on pc/ras1.zarr\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc/ras1.zarr zarray shape: (100, 100)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc/ras1.zarr zarray chunks: (20, 100)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc/ras1.zarr zarray dtype: float32\n2023-10-14 22:42:29 - de_ras2pc - INFO - hd_chunk_size not setted. Use the one from pc/ras1.zarr.\n2023-10-14 22:42:29 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-10-14 22:42:29 - de_ras2pc - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:42:29 - de_ras2pc - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:42:29 - de_ras2pc - INFO - ras dask array dtype: float32\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array chunksize: (213,)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:29 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:42:29 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:29 - de_ras2pc - INFO - saving to pc/pc1.zarr.\n2023-10-14 22:42:29 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:29 - de_ras2pc - INFO - computing finished.\n2023-10-14 22:42:30 - de_ras2pc - INFO - dask cluster closed.\n2023-10-14 22:42:31 - de_ras2pc - INFO - fetching args:\n2023-10-14 22:42:31 - de_ras2pc - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:31 - de_ras2pc - INFO - ras = 'pc/ras2.zarr'\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc = 'pc/pc2.zarr'\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc_chunk_size = None\n2023-10-14 22:42:31 - de_ras2pc - INFO - hd_chunk_size = (1,)\n2023-10-14 22:42:31 - de_ras2pc - INFO - log = None\n2023-10-14 22:42:31 - de_ras2pc - INFO - fetching args done.\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:42:31 - de_ras2pc - INFO - no input pc_chunk_size, use pc_chunk_size as input idx\n2023-10-14 22:42:31 - de_ras2pc - INFO - pc_chunk_size: 200\n2023-10-14 22:42:31 - de_ras2pc - INFO - loading idx into memory.\n2023-10-14 22:42:31 - de_ras2pc - INFO - starting dask local cluster.\n2023-10-14 22:42:34 - de_ras2pc - INFO - dask local cluster started.\n2023-10-14 22:42:34 - de_ras2pc - INFO - start to slice on pc/ras2.zarr\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc/ras2.zarr zarray shape: (100, 100, 3)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc/ras2.zarr zarray chunks: (20, 100, 1)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc/ras2.zarr zarray dtype: complex64\n2023-10-14 22:42:34 - de_ras2pc - INFO - hd_chunk_size: (1,).\n2023-10-14 22:42:34 - de_ras2pc - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:42:34 - de_ras2pc - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:42:34 - de_ras2pc - INFO - ras dask array dtype: complex64\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array chunksize: (213, 1)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:34 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:42:34 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:34 - de_ras2pc - INFO - saving to pc/pc2.zarr.\n2023-10-14 22:42:34 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:35 - de_ras2pc - INFO - computing finished.\n2023-10-14 22:42:35 - de_ras2pc - INFO - dask cluster closed.\n2023-10-14 22:42:36 - de_ras2pc - INFO - fetching args:\n2023-10-14 22:42:36 - de_ras2pc - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:36 - de_ras2pc - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc_chunk_size = None\n2023-10-14 22:42:36 - de_ras2pc - INFO - hd_chunk_size = [(), (1,)]\n2023-10-14 22:42:36 - de_ras2pc - INFO - log = None\n2023-10-14 22:42:36 - de_ras2pc - INFO - fetching args done.\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:42:36 - de_ras2pc - INFO - no input pc_chunk_size, use pc_chunk_size as input idx\n2023-10-14 22:42:36 - de_ras2pc - INFO - pc_chunk_size: 200\n2023-10-14 22:42:36 - de_ras2pc - INFO - loading idx into memory.\n2023-10-14 22:42:36 - de_ras2pc - INFO - starting dask local cluster.\n2023-10-14 22:42:38 - de_ras2pc - INFO - dask local cluster started.\n2023-10-14 22:42:38 - de_ras2pc - INFO - start to slice on pc/ras1.zarr\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras1.zarr zarray shape: (100, 100)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras1.zarr zarray chunks: (20, 100)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras1.zarr zarray dtype: float32\n2023-10-14 22:42:38 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array dtype: float32\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array chunksize: (213,)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:38 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:38 - de_ras2pc - INFO - saving to pc/pc1.zarr.\n2023-10-14 22:42:38 - de_ras2pc - INFO - start to slice on pc/ras2.zarr\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras2.zarr zarray shape: (100, 100, 3)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras2.zarr zarray chunks: (20, 100, 1)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc/ras2.zarr zarray dtype: complex64\n2023-10-14 22:42:38 - de_ras2pc - INFO - hd_chunk_size: (1,).\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:42:38 - de_ras2pc - INFO - ras dask array dtype: complex64\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array chunksize: (213, 1)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:38 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:42:38 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:38 - de_ras2pc - INFO - saving to pc/pc2.zarr.\n2023-10-14 22:42:38 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:39 - de_ras2pc - INFO - computing finished.\n2023-10-14 22:42:39 - de_ras2pc - INFO - dask cluster closed.\n2023-10-14 22:42:40 - de_ras2pc - INFO - fetching args:\n2023-10-14 22:42:40 - de_ras2pc - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:40 - de_ras2pc - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc_chunk_size = None\n2023-10-14 22:42:40 - de_ras2pc - INFO - hd_chunk_size = [(), (1,)]\n2023-10-14 22:42:40 - de_ras2pc - INFO - log = None\n2023-10-14 22:42:40 - de_ras2pc - INFO - fetching args done.\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc/idx.zarr zarray shape: (2, 1000)\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc/idx.zarr zarray chunks: (2, 200)\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:42:40 - de_ras2pc - INFO - no input pc_chunk_size, use pc_chunk_size as input idx\n2023-10-14 22:42:40 - de_ras2pc - INFO - pc_chunk_size: 200\n2023-10-14 22:42:40 - de_ras2pc - INFO - loading idx into memory.\n2023-10-14 22:42:40 - de_ras2pc - INFO - starting dask local cluster.\n2023-10-14 22:42:43 - de_ras2pc - INFO - dask local cluster started.\n2023-10-14 22:42:43 - de_ras2pc - INFO - start to slice on pc/ras1.zarr\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras1.zarr zarray shape: (100, 100)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras1.zarr zarray chunks: (20, 100)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras1.zarr zarray dtype: float32\n2023-10-14 22:42:43 - de_ras2pc - INFO - hd_chunk_size: ().\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array dtype: float32\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array chunksize: (213,)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:43 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array dtype: float32\n2023-10-14 22:42:43 - de_ras2pc - INFO - saving to pc/pc1.zarr.\n2023-10-14 22:42:43 - de_ras2pc - INFO - start to slice on pc/ras2.zarr\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras2.zarr zarray shape: (100, 100, 3)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras2.zarr zarray chunks: (20, 100, 1)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc/ras2.zarr zarray dtype: complex64\n2023-10-14 22:42:43 - de_ras2pc - INFO - hd_chunk_size: (1,).\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:42:43 - de_ras2pc - INFO - ras dask array dtype: complex64\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array chunksize: (213, 1)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:43 - de_ras2pc - INFO - rechunk pc data:\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:42:43 - de_ras2pc - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:43 - de_ras2pc - INFO - saving to pc/pc2.zarr.\n2023-10-14 22:42:43 - de_ras2pc - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:45 - de_ras2pc - INFO - computing finished.\n2023-10-14 22:42:45 - de_ras2pc - INFO - dask cluster closed.\n\n\n2023-10-14 22:42:39,280 - distributed.worker - ERROR - Failed to communicate with scheduler during heartbeat.\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1427, in _connect\n    comm = await connect(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/core.py\", line 329, in connect\n    handshake = await wait_for(comm.read(), time_left())\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils.py\", line 1849, in wait_for\n    return await asyncio.wait_for(fut, timeout)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/asyncio/tasks.py\", line 432, in wait_for\n    await waiter\nasyncio.exceptions.CancelledError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1244, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 434, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 413, in retry\n    return await coro()\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1262, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1506, in connect\n    return await connect_attempt\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1450, in _connect\n    raise CommClosedError(reason)\ndistributed.comm.core.CommClosedError: ConnectionPool closing.\n2023-10-14 22:42:39,286 - distributed.worker - ERROR - Failed to communicate with scheduler during heartbeat.\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1427, in _connect\n    comm = await connect(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/core.py\", line 329, in connect\n    handshake = await wait_for(comm.read(), time_left())\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils.py\", line 1849, in wait_for\n    return await asyncio.wait_for(fut, timeout)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/asyncio/tasks.py\", line 432, in wait_for\n    await waiter\nasyncio.exceptions.CancelledError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1244, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 434, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 413, in retry\n    return await coro()\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1262, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1506, in connect\n    return await connect_attempt\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1450, in _connect\n    raise CommClosedError(reason)\ndistributed.comm.core.CommClosedError: ConnectionPool closing.\n\n\n\nsource\n\n\nde_pc2ras\n\n de_pc2ras (idx:str, pc:str|list, ras:str|list, shape:tuple,\n            az_chunk_size:int=None, log:str=None)\n\nConvert point cloud data to raster data, filled with nan\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx\nstr\n\npoint cloud index\n\n\npc\nstr | list\n\npath (in string) or list of path for point cloud data\n\n\nras\nstr | list\n\noutput, path (in string) or list of path for raster data\n\n\nshape\ntuple\n\nshape of one image (nlines,width)\n\n\naz_chunk_size\nint\nNone\noutput azimuth chunk size, automatically set az_chunk_size to make n_az_chunk equals to n_pc_chunk by default\n\n\nlog\nstr\nNone\nlog file. Default: no log file\n\n\n\n\n!de_pc2ras -h\n\nusage: de_pc2ras [-h] --pc PC [PC ...] --ras RAS [RAS ...] --shape SHAPE\n                 [--az_chunk_size AZ_CHUNK_SIZE] [--log LOG]\n                 idx\n\nConvert point cloud data to raster data\n\npositional arguments:\n  idx                            point cloud index\n\noptions:\n  -h, --help                     show this help message and exit\n  --pc PC [PC ...]               one or more path for point cloud data\n  --ras RAS [RAS ...]            output, one or more path for raster data\n  --shape SHAPE                  shape of one image \"nlines,width\"\n  --az_chunk_size AZ_CHUNK_SIZE  output azimuth chunk size, only one chunk by\n                                 default\n  --log LOG                      log file. Default: no log file\n\n\nUsage:\n\npc_data1 = np.random.rand(1000).astype(np.float32)\npc_data2 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\nidx = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx.sort()\nidx = np.stack(np.unravel_index(idx,shape=(100,100))).astype(np.int32)\n\nras_data1 = np.zeros((100,100),dtype=np.float32)\nras_data2 = np.zeros((100,100,3),dtype=np.complex64)\nras_data1[:] = np.nan\nras_data2[:] = np.nan\n\nras_data1[idx[0],idx[1]] = pc_data1\nras_data2[idx[0],idx[1]] = pc_data2\n\nidx_zarr = zarr.open('pc/idx.zarr','w',shape=idx.shape,dtype=idx.dtype,chunks=(2,200))\npc_zarr1 = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,))\npc_zarr2 = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx_zarr[:] = idx\npc_zarr1[:] = pc_data1\npc_zarr2[:] = pc_data2\n\n\nde_pc2ras('pc/idx.zarr','pc/pc1.zarr','pc/ras1.zarr',shape=(100,100),az_chunk_size=20)\nras_zarr1 = zarr.open('pc/ras1.zarr','r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\n\n!de_pc2ras pc/idx.zarr/ --pc pc/pc2.zarr/ --ras pc/ras2.zarr/ --shape \"100,100\" --az_chunk_size 20\nras_zarr2 = zarr.open('pc/ras2.zarr','r')\nnp.testing.assert_array_equal(ras_data2,ras_zarr2[:])\n\nde_pc2ras('pc/idx.zarr',['pc/pc1.zarr','pc/pc2.zarr'],['pc/ras1.zarr','pc/ras2.zarr'],shape=(100,100),az_chunk_size=20)\nras_zarr1 = zarr.open('pc/ras1.zarr','r')\nras_zarr2 = zarr.open('pc/ras2.zarr','r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\nnp.testing.assert_array_equal(ras_data2,ras_zarr2[:])\n\n!de_pc2ras pc/idx.zarr/ --pc pc/pc1.zarr/ pc/pc2.zarr/ --ras pc/ras1.zarr/ pc/ras2.zarr/ --shape \"100,100\" --az_chunk_size 20\nras_zarr1 = zarr.open('pc/ras1.zarr','r')\nras_zarr2 = zarr.open('pc/ras2.zarr','r')\nnp.testing.assert_array_equal(ras_data1,ras_zarr1[:])\nnp.testing.assert_array_equal(ras_data2,ras_zarr2[:])\n\n2023-10-14 22:42:47 - de_pc2ras - INFO - fetching args:\n2023-10-14 22:42:47 - de_pc2ras - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:47 - de_pc2ras - INFO - pc = 'pc/pc1.zarr'\n2023-10-14 22:42:47 - de_pc2ras - INFO - ras = 'pc/ras1.zarr'\n2023-10-14 22:42:47 - de_pc2ras - INFO - shape = (100, 100)\n2023-10-14 22:42:47 - de_pc2ras - INFO - az_chunk_size = 20\n2023-10-14 22:42:47 - de_pc2ras - INFO - log = None\n2023-10-14 22:42:47 - de_pc2ras - INFO - fetching args done.\n2023-10-14 22:42:47 - de_pc2ras - INFO - idx dataset shape: (2, 1000)\n2023-10-14 22:42:47 - de_pc2ras - INFO - idx dataset chunks: (2, 200)\n2023-10-14 22:42:47 - de_pc2ras - INFO - az_chunk_size: 20\n2023-10-14 22:42:47 - de_pc2ras - INFO - loading idx into memory.\n2023-10-14 22:42:47 - de_pc2ras - INFO - starting dask local cluster.\n2023-10-14 22:42:49 - de_pc2ras - INFO - dask local cluster started.\n2023-10-14 22:42:49 - de_pc2ras - INFO - start to work on pc/pc1.zarr\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc/pc1.zarr zarray shape: (1000,)\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc/pc1.zarr zarray chunks: (200,)\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc/pc1.zarr zarray dtype: float32\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:42:49 - de_pc2ras - INFO - pc dask array dtype: float32\n2023-10-14 22:42:49 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:42:49 - de_pc2ras - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:42:49 - de_pc2ras - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:42:49 - de_pc2ras - INFO - ras dask array dtype: float32\n2023-10-14 22:42:49 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:50 - de_pc2ras - INFO - computing finished.\n2023-10-14 22:42:50 - de_pc2ras - INFO - dask cluster closed.\n2023-10-14 22:42:52 - de_pc2ras - INFO - fetching args:\n2023-10-14 22:42:52 - de_pc2ras - INFO - idx = 'pc/idx.zarr/'\n2023-10-14 22:42:52 - de_pc2ras - INFO - pc = 'pc/pc2.zarr/'\n2023-10-14 22:42:52 - de_pc2ras - INFO - ras = 'pc/ras2.zarr/'\n2023-10-14 22:42:52 - de_pc2ras - INFO - shape = (100, 100)\n2023-10-14 22:42:52 - de_pc2ras - INFO - az_chunk_size = 20\n2023-10-14 22:42:52 - de_pc2ras - INFO - log = None\n2023-10-14 22:42:52 - de_pc2ras - INFO - fetching args done.\n2023-10-14 22:42:52 - de_pc2ras - INFO - idx dataset shape: (2, 1000)\n2023-10-14 22:42:52 - de_pc2ras - INFO - idx dataset chunks: (2, 200)\n2023-10-14 22:42:52 - de_pc2ras - INFO - az_chunk_size: 20\n2023-10-14 22:42:52 - de_pc2ras - INFO - loading idx into memory.\n2023-10-14 22:42:52 - de_pc2ras - INFO - starting dask local cluster.\n2023-10-14 22:42:55 - de_pc2ras - INFO - dask local cluster started.\n2023-10-14 22:42:55 - de_pc2ras - INFO - start to work on pc/pc2.zarr/\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc/pc2.zarr/ zarray shape: (1000, 3)\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc/pc2.zarr/ zarray chunks: (200, 1)\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc/pc2.zarr/ zarray dtype: complex64\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:42:55 - de_pc2ras - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:55 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:42:55 - de_pc2ras - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:42:55 - de_pc2ras - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:42:55 - de_pc2ras - INFO - ras dask array dtype: complex64\n2023-10-14 22:42:55 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:56 - de_pc2ras - INFO - computing finished.\n2023-10-14 22:42:56 - de_pc2ras - INFO - dask cluster closed.\n2023-10-14 22:42:57 - de_pc2ras - INFO - fetching args:\n2023-10-14 22:42:57 - de_pc2ras - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:42:57 - de_pc2ras - INFO - pc = ['pc/pc1.zarr', 'pc/pc2.zarr']\n2023-10-14 22:42:57 - de_pc2ras - INFO - ras = ['pc/ras1.zarr', 'pc/ras2.zarr']\n2023-10-14 22:42:57 - de_pc2ras - INFO - shape = (100, 100)\n2023-10-14 22:42:57 - de_pc2ras - INFO - az_chunk_size = 20\n2023-10-14 22:42:57 - de_pc2ras - INFO - log = None\n2023-10-14 22:42:57 - de_pc2ras - INFO - fetching args done.\n2023-10-14 22:42:57 - de_pc2ras - INFO - idx dataset shape: (2, 1000)\n2023-10-14 22:42:57 - de_pc2ras - INFO - idx dataset chunks: (2, 200)\n2023-10-14 22:42:57 - de_pc2ras - INFO - az_chunk_size: 20\n2023-10-14 22:42:57 - de_pc2ras - INFO - loading idx into memory.\n2023-10-14 22:42:57 - de_pc2ras - INFO - starting dask local cluster.\n2023-10-14 22:42:58 - de_pc2ras - INFO - dask local cluster started.\n2023-10-14 22:42:58 - de_pc2ras - INFO - start to work on pc/pc1.zarr\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc1.zarr zarray shape: (1000,)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc1.zarr zarray chunks: (200,)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc1.zarr zarray dtype: float32\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array shape: (1000,)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array dtype: float32\n2023-10-14 22:42:58 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array dtype: float32\n2023-10-14 22:42:58 - de_pc2ras - INFO - start to work on pc/pc2.zarr\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc2.zarr zarray shape: (1000, 3)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:42:58 - de_pc2ras - INFO - pc dask array dtype: complex64\n2023-10-14 22:42:58 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:42:58 - de_pc2ras - INFO - ras dask array dtype: complex64\n2023-10-14 22:42:59 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:42:59 - de_pc2ras - INFO - computing finished.\n2023-10-14 22:43:00 - de_pc2ras - INFO - dask cluster closed.\n2023-10-14 22:43:01 - de_pc2ras - INFO - fetching args:\n2023-10-14 22:43:01 - de_pc2ras - INFO - idx = 'pc/idx.zarr/'\n2023-10-14 22:43:01 - de_pc2ras - INFO - pc = ['pc/pc1.zarr/', 'pc/pc2.zarr/']\n2023-10-14 22:43:01 - de_pc2ras - INFO - ras = ['pc/ras1.zarr/', 'pc/ras2.zarr/']\n2023-10-14 22:43:01 - de_pc2ras - INFO - shape = (100, 100)\n2023-10-14 22:43:01 - de_pc2ras - INFO - az_chunk_size = 20\n2023-10-14 22:43:01 - de_pc2ras - INFO - log = None\n2023-10-14 22:43:01 - de_pc2ras - INFO - fetching args done.\n2023-10-14 22:43:01 - de_pc2ras - INFO - idx dataset shape: (2, 1000)\n2023-10-14 22:43:01 - de_pc2ras - INFO - idx dataset chunks: (2, 200)\n2023-10-14 22:43:01 - de_pc2ras - INFO - az_chunk_size: 20\n2023-10-14 22:43:01 - de_pc2ras - INFO - loading idx into memory.\n2023-10-14 22:43:01 - de_pc2ras - INFO - starting dask local cluster.\n2023-10-14 22:43:04 - de_pc2ras - INFO - dask local cluster started.\n2023-10-14 22:43:04 - de_pc2ras - INFO - start to work on pc/pc1.zarr/\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc1.zarr/ zarray shape: (1000,)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc1.zarr/ zarray chunks: (200,)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc1.zarr/ zarray dtype: float32\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array shape: (1000,)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array chunksize: (200,)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array dtype: float32\n2023-10-14 22:43:04 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array shape: (100, 100)\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array chunksize: (20, 100)\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array dtype: float32\n2023-10-14 22:43:04 - de_pc2ras - INFO - start to work on pc/pc2.zarr/\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc2.zarr/ zarray shape: (1000, 3)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc2.zarr/ zarray chunks: (200, 1)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc/pc2.zarr/ zarray dtype: complex64\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array shape: (1000, 3)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array chunksize: (200, 1)\n2023-10-14 22:43:04 - de_pc2ras - INFO - pc dask array dtype: complex64\n2023-10-14 22:43:04 - de_pc2ras - INFO - create ras dask array\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array shape: (100, 100, 3)\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array chunksize: (20, 100, 1)\n2023-10-14 22:43:04 - de_pc2ras - INFO - ras dask array dtype: complex64\n2023-10-14 22:43:04 - de_pc2ras - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:43:05 - de_pc2ras - INFO - computing finished.\n2023-10-14 22:43:05,188 - distributed.worker - ERROR - Failed to communicate with scheduler during heartbeat.\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/tcp.py\", line 225, in read\n    frames_nbytes = await stream.read_bytes(fmt_size)\ntornado.iostream.StreamClosedError: Stream is closed\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1244, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 434, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 413, in retry\n    return await coro()\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1265, in send_recv_from_rpc\n    return await send_recv(comm=comm, op=key, **kwargs)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1024, in send_recv\n    response = await comm.read(deserializers=deserializers)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/tcp.py\", line 241, in read\n    convert_stream_closed_error(self, e)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/tcp.py\", line 144, in convert_stream_closed_error\n    raise CommClosedError(f\"in {obj}: {exc}\") from exc\ndistributed.comm.core.CommClosedError: in &lt;TCP (closed) ConnectionPool.heartbeat_worker local=tcp://127.0.0.1:57274 remote=tcp://127.0.0.1:34963&gt;: Stream is closed\n2023-10-14 22:43:05,201 - distributed.scheduler - WARNING - Received heartbeat from unregistered worker 'tcp://127.0.0.1:40669'.\n2023-10-14 22:43:05 - de_pc2ras - INFO - dask cluster closed.\n\n\n2023-10-14 22:42:59,764 - distributed.worker - ERROR - Failed to communicate with scheduler during heartbeat.\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1427, in _connect\n    comm = await connect(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/comm/core.py\", line 329, in connect\n    handshake = await wait_for(comm.read(), time_left())\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils.py\", line 1849, in wait_for\n    return await asyncio.wait_for(fut, timeout)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/asyncio/tasks.py\", line 432, in wait_for\n    await waiter\nasyncio.exceptions.CancelledError\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/worker.py\", line 1244, in heartbeat\n    response = await retry_operation(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 434, in retry_operation\n    return await retry(\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/utils_comm.py\", line 413, in retry\n    return await coro()\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1262, in send_recv_from_rpc\n    comm = await self.pool.connect(self.addr)\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1506, in connect\n    return await connect_attempt\n  File \"/users/kangl/miniconda3/envs/work/lib/python3.10/site-packages/distributed/core.py\", line 1450, in _connect\n    raise CommClosedError(reason)\ndistributed.comm.core.CommClosedError: ConnectionPool closing.\n\n\n\nsource\n\n\nde_pc_union\n\n de_pc_union (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n              pc2:str|list=None, pc:str|list=None, pc_chunk_size:int=None,\n              n_pc_chunk:int=None, log:str=None)\n\nGet the union of two point cloud dataset. For points at their intersection, pc_data1 rather than pc_data2 is copied to the result pc_data. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional, only one chunk if both pc_chunk_size and n_pc_chunk are not set.\n\n\nlog\nstr\nNone\nlog file. Default: no log file\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, inv_iidx1, inv_iidx2, iidx2 = pc_union(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\nde_pc_union('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr','pc/pc1.zarr','pc/pc2.zarr','pc/pc.zarr')\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-10-14 22:43:06 - de_pc_union - INFO - fetching args:\n2023-10-14 22:43:06 - de_pc_union - INFO - idx1 = 'pc/idx1.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - idx2 = 'pc/idx2.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - pc1 = 'pc/pc1.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - pc2 = 'pc/pc2.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - pc = 'pc/pc.zarr'\n2023-10-14 22:43:06 - de_pc_union - INFO - pc_chunk_size = None\n2023-10-14 22:43:06 - de_pc_union - INFO - n_pc_chunk = None\n2023-10-14 22:43:06 - de_pc_union - INFO - log = None\n2023-10-14 22:43:06 - de_pc_union - INFO - fetching args done.\n2023-10-14 22:43:06 - de_pc_union - INFO - idx1 zarray shape: (2, 1000)\n2023-10-14 22:43:06 - de_pc_union - INFO - idx1 zarray chunks: (2, 200)\n2023-10-14 22:43:06 - de_pc_union - INFO - idx1 zarray dtype: int32\n2023-10-14 22:43:06 - de_pc_union - INFO - idx2 zarray shape: (2, 800)\n2023-10-14 22:43:06 - de_pc_union - INFO - idx2 zarray chunks: (2, 200)\n2023-10-14 22:43:06 - de_pc_union - INFO - idx2 zarray dtype: int32\n2023-10-14 22:43:06 - de_pc_union - INFO - loading idx1 and idx2 into memory.\n2023-10-14 22:43:06 - de_pc_union - INFO - calculate the union\n2023-10-14 22:43:06 - de_pc_union - INFO - number of points in the union: 1727\n2023-10-14 22:43:06 - de_pc_union - INFO - use n_pc_chunk from the idx1\n2023-10-14 22:43:06 - de_pc_union - INFO - got n_pc_chunk: 5\n2023-10-14 22:43:06 - de_pc_union - INFO - automatically determine pc_chunk_size from n_pc and n_pc_chunk\n2023-10-14 22:43:06 - de_pc_union - INFO - pc_chunk_size: 346\n2023-10-14 22:43:06 - de_pc_union - INFO - write union idx\n2023-10-14 22:43:06 - de_pc_union - INFO - write done\n2023-10-14 22:43:06 - de_pc_union - INFO - pc/idx.zarr zarray shape: (2, 1727)\n2023-10-14 22:43:06 - de_pc_union - INFO - pc/idx.zarr zarray chunks: (2, 346)\n2023-10-14 22:43:06 - de_pc_union - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:43:06 - de_pc_union - INFO - starting dask local cluster.\n2023-10-14 22:43:07 - de_pc_union - INFO - dask local cluster started.\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc1.zarr zarray shape: (1000, 3)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc1.zarr zarray chunks: (200, 1)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc1.zarr zarray dtype: complex64\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc2.zarr zarray shape: (800, 3)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-10-14 22:43:07 - de_pc_union - INFO - pc1 dask array shape: (1000, 3)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc1 dask array chunksize: (200, 1)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc1 dask array dtype: complex64\n2023-10-14 22:43:07 - de_pc_union - INFO - pc2 dask array shape: (800, 3)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc2 dask array chunksize: (200, 1)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc2 dask array dtype: complex64\n2023-10-14 22:43:07 - de_pc_union - INFO - set up union pc data dask array.\n2023-10-14 22:43:07 - de_pc_union - INFO - pc dask array shape: (1727, 3)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc dask array chunksize: (346, 1)\n2023-10-14 22:43:07 - de_pc_union - INFO - pc dask array dtype: complex64\n2023-10-14 22:43:07 - de_pc_union - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:43:08 - de_pc_union - INFO - computing finished.\n2023-10-14 22:43:09 - de_pc_union - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc_intersect\n\n de_pc_intersect (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n                  pc2:str|list=None, pc:str|list=None,\n                  pc_chunk_size:int=None, n_pc_chunk:int=None,\n                  prefer_1=True, log:str=None)\n\nGet the intersection of two point cloud dataset. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc2\nstr | list\nNone\npath (in string) or list of path for the second point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional, only one chunk if both pc_chunk_size and n_pc_chunk are not set.\n\n\nprefer_1\nbool\nTrue\nsave pc1 on intersection to output pc dataset by default True. Otherwise, save data from pc2\n\n\nlog\nstr\nNone\nlog file. Default: no log file\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\npc_data2 = np.random.rand(800,3).astype(np.float32)+1j*np.random.rand(800,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, iidx1, iidx2 = pc_intersect(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data2[iidx2]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\npc2_zarr = zarr.open('pc/pc2.zarr','w',shape=pc_data2.shape,dtype=pc_data2.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\npc2_zarr[:] = pc_data2\n\n\nde_pc_intersect('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr',pc2='pc/pc2.zarr', pc='pc/pc.zarr',prefer_1=False)\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-10-14 22:43:09 - de_pc_intersect - INFO - fetching args:\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx1 = 'pc/idx1.zarr'\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx2 = 'pc/idx2.zarr'\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc1 = None\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc2 = 'pc/pc2.zarr'\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc = 'pc/pc.zarr'\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc_chunk_size = None\n2023-10-14 22:43:09 - de_pc_intersect - INFO - n_pc_chunk = None\n2023-10-14 22:43:09 - de_pc_intersect - INFO - prefer_1 = False\n2023-10-14 22:43:09 - de_pc_intersect - INFO - log = None\n2023-10-14 22:43:09 - de_pc_intersect - INFO - fetching args done.\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx1 zarray shape: (2, 1000)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx1 zarray chunks: (2, 200)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx1 zarray dtype: int32\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx2 zarray shape: (2, 800)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx2 zarray chunks: (2, 200)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - idx2 zarray dtype: int32\n2023-10-14 22:43:09 - de_pc_intersect - INFO - loading idx1 and idx2 into memory.\n2023-10-14 22:43:09 - de_pc_intersect - INFO - calculate the intersection\n2023-10-14 22:43:09 - de_pc_intersect - INFO - number of points in the intersection: 71\n2023-10-14 22:43:09 - de_pc_intersect - INFO - use n_pc_chunk from the idx1\n2023-10-14 22:43:09 - de_pc_intersect - INFO - got n_pc_chunk: 5\n2023-10-14 22:43:09 - de_pc_intersect - INFO - automatically determine pc_chunk_size from n_pc and n_pc_chunk\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc_chunk_size: 15\n2023-10-14 22:43:09 - de_pc_intersect - INFO - write intersect idx\n2023-10-14 22:43:09 - de_pc_intersect - INFO - write done\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc/idx.zarr zarray shape: (2, 71)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc/idx.zarr zarray chunks: (2, 15)\n2023-10-14 22:43:09 - de_pc_intersect - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:43:09 - de_pc_intersect - INFO - select pc2 as pc_input.\n2023-10-14 22:43:09 - de_pc_intersect - INFO - starting dask local cluster.\n2023-10-14 22:43:11 - de_pc_intersect - INFO - dask local cluster started.\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc/pc2.zarr zarray shape: (800, 3)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc/pc2.zarr zarray chunks: (200, 1)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc/pc2.zarr zarray dtype: complex64\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc_input dask array shape: (800, 3)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc_input dask array chunksize: (200, 1)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc_input dask array dtype: complex64\n2023-10-14 22:43:11 - de_pc_intersect - INFO - set up intersect pc data dask array.\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc dask array shape: (71, 3)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc dask array chunksize: (15, 1)\n2023-10-14 22:43:11 - de_pc_intersect - INFO - pc dask array dtype: complex64\n2023-10-14 22:43:11 - de_pc_intersect - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:43:12 - de_pc_intersect - INFO - computing finished.\n2023-10-14 22:43:12 - de_pc_intersect - INFO - dask cluster closed.\n\n\n\nsource\n\n\nde_pc_diff\n\n de_pc_diff (idx1:str, idx2:str, idx:str, pc1:str|list=None,\n             pc:str|list=None, pc_chunk_size:int=None,\n             n_pc_chunk:int=None, log:str=None)\n\nGet the point cloud in idx1 that are not in idx2. pc_chunk_size and n_pc_chunk are used to determine the final pc_chunk_size. If non of them are provided, the n_pc_chunk is set to n_chunk in idx1.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nidx1\nstr\n\nindex of the first point cloud\n\n\nidx2\nstr\n\nindex of the second point cloud\n\n\nidx\nstr\n\noutput, index of the union point cloud\n\n\npc1\nstr | list\nNone\npath (in string) or list of path for the first point cloud data\n\n\npc\nstr | list\nNone\noutput, path (in string) or list of path for the union point cloud data\n\n\npc_chunk_size\nint\nNone\nchunk size in output data,optional\n\n\nn_pc_chunk\nint\nNone\nnumber of chunk in output data, optional, only one chunk if both pc_chunk_size and n_pc_chunk are not set.\n\n\nlog\nstr\nNone\nlog file. Default: no log file\n\n\n\nUsage:\n\npc_data1 = np.random.rand(1000,3).astype(np.float32)+1j*np.random.rand(1000,3).astype(np.float32)\n\nidx1 = np.random.choice(np.arange(100*100,dtype=np.int32),size=1000,replace=False)\nidx1.sort()\nidx1 = np.stack(np.unravel_index(idx1,shape=(100,100))).astype(np.int32)\n\nidx2 = np.random.choice(np.arange(100*100,dtype=np.int32),size=800,replace=False)\nidx2.sort()\nidx2 = np.stack(np.unravel_index(idx2,shape=(100,100))).astype(np.int32)\n\nidx, iidx1 = pc_diff(idx1,idx2)\n\npc_data = np.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[:] = pc_data1[iidx1]\n\nidx1_zarr = zarr.open('pc/idx1.zarr','w',shape=idx1.shape,dtype=idx1.dtype,chunks=(2,200))\nidx2_zarr = zarr.open('pc/idx2.zarr','w',shape=idx2.shape,dtype=idx2.dtype,chunks=(2,200))\npc1_zarr = zarr.open('pc/pc1.zarr','w',shape=pc_data1.shape,dtype=pc_data1.dtype,chunks=(200,1))\nidx1_zarr[:] = idx1\nidx2_zarr[:] = idx2\npc1_zarr[:] = pc_data1\n\n\nde_pc_diff('pc/idx1.zarr','pc/idx2.zarr','pc/idx.zarr',pc1='pc/pc1.zarr', pc='pc/pc.zarr')\nidx_zarr = zarr.open('pc/idx.zarr','r')\npc_zarr = zarr.open('pc/pc.zarr','r')\nnp.testing.assert_array_equal(idx_zarr[:],idx)\nnp.testing.assert_array_equal(pc_zarr[:],pc_data)\n\n2023-10-14 22:43:12 - de_pc_diff - INFO - fetching args:\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx1 = 'pc/idx1.zarr'\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx2 = 'pc/idx2.zarr'\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx = 'pc/idx.zarr'\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc1 = 'pc/pc1.zarr'\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc = 'pc/pc.zarr'\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc_chunk_size = None\n2023-10-14 22:43:12 - de_pc_diff - INFO - n_pc_chunk = None\n2023-10-14 22:43:12 - de_pc_diff - INFO - log = None\n2023-10-14 22:43:12 - de_pc_diff - INFO - fetching args done.\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx1 zarray shape: (2, 1000)\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx1 zarray chunks: (2, 200)\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx1 zarray dtype: int32\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx2 zarray shape: (2, 800)\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx2 zarray chunks: (2, 200)\n2023-10-14 22:43:12 - de_pc_diff - INFO - idx2 zarray dtype: int32\n2023-10-14 22:43:12 - de_pc_diff - INFO - loading idx1 and idx2 into memory.\n2023-10-14 22:43:12 - de_pc_diff - INFO - calculate the diff.\n2023-10-14 22:43:12 - de_pc_diff - INFO - number of points in the diff: 914\n2023-10-14 22:43:12 - de_pc_diff - INFO - use n_pc_chunk from the idx1\n2023-10-14 22:43:12 - de_pc_diff - INFO - got n_pc_chunk: 5\n2023-10-14 22:43:12 - de_pc_diff - INFO - automatically determine pc_chunk_size from n_pc and n_pc_chunk\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc_chunk_size: 183\n2023-10-14 22:43:12 - de_pc_diff - INFO - write intersect idx\n2023-10-14 22:43:12 - de_pc_diff - INFO - write done\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc/idx.zarr zarray shape: (2, 914)\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc/idx.zarr zarray chunks: (2, 183)\n2023-10-14 22:43:12 - de_pc_diff - INFO - pc/idx.zarr zarray dtype: int32\n2023-10-14 22:43:12 - de_pc_diff - INFO - starting dask local cluster.\n2023-10-14 22:43:14 - de_pc_diff - INFO - dask local cluster started.\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc/pc1.zarr zarray shape: (1000, 3)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc/pc1.zarr zarray chunks: (200, 1)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc/pc1.zarr zarray dtype: complex64\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc1 dask array shape: (1000, 3)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc1 dask array chunksize: (200, 1)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc1 dask array dtype: complex64\n2023-10-14 22:43:14 - de_pc_diff - INFO - set up diff pc data dask array.\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc dask array shape: (914, 3)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc dask array chunksize: (183, 1)\n2023-10-14 22:43:14 - de_pc_diff - INFO - pc dask array dtype: complex64\n2023-10-14 22:43:14 - de_pc_diff - INFO - computing graph setted. doing all the computing.\n2023-10-14 22:43:15 - de_pc_diff - INFO - computing finished.\n2023-10-14 22:43:15 - de_pc_diff - INFO - dask cluster closed."
  },
  {
    "objectID": "CLI/load.html",
    "href": "CLI/load.html",
    "title": "load",
    "section": "",
    "text": "source\n\nde_load_gamma_flatten_rslc\n\n de_load_gamma_flatten_rslc (rslc_dir:str, reference:str, hgt:str,\n                             rslc_zarr:str, az_chunk_size:int=-1,\n                             log:str=None)\n\nGenerate flatten rslc data from gamma command and convert them into zarr format. The shape of hgt should be same as one rslc image, i.e. the hgt file is generated with 1 by 1 look geocoding.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_dir\nstr\n\ngamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\nreference\nstr\n\nreference date, eg: ‘20200202’\n\n\nhgt\nstr\n\nthe DEM in radar coordinate\n\n\nrslc_zarr\nstr\n\noutput, the flattened rslcs stack in zarr format\n\n\naz_chunk_size\nint\n-1\nrslcs stack azimuth chunk size, azimuth number of lines by default (one chunk)\n\n\nlog\nstr\nNone\nlogfile, no log by default\n\n\n\nThe method behind the flattened RSLC:\nLet the value of i-th rslc be \\(s_i\\), the simulated phase due to DEM and position difference be \\(u_{ij}\\). D-InSAR basically is: \\[d_{ij}=s_i \\times s_j^* \\times e^{-ju_{ij}}.\\] Let the distance between satellite and ground target for th i-th observation be \\(l_i\\). Then, the simulated phase for DInSAR \\[u_{ij} = l_i-l_j.\\] So, a simple conclusion is \\[u_{ij}-u_{ik}=-u_{jk}.\\] If we define \\[s_i^{\\prime} = s_i \\times e^{ju_{xi}},\\] where \\(X\\) can be any arbitrary interger less than \\(N\\)- the total number of the RSLCs. Then we can find that \\[int_{ij}^{\\prime} =  s_i^{\\prime} \\times s_j^{\\prime*} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{j(u_{xi}-u_{xj})} = s_i \\times s_j^* \\times e^{-ju_{ij}} = d_{ij}.\\]\nWe call \\(s_i^{\\prime}\\) as flattened RSLC. The advantage of flattened RSLC is DInSAR can be easily calculated by simple conjugate multiplication.\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nrslc_zarr = './raw/rslc.zarr'\naz_chunk_size = 1000\n\n\nde_load_gamma_flatten_rslc(rslc_dir,reference,hgt,rslc_zarr,az_chunk_size)\n\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - fetching args:\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - reference = '20220620'\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - rslc_zarr = './raw/rslc.zarr'\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - az_chunk_size = 1000\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - log = None\n2023-10-12 23:16:13 - de_load_gamma_flatten_rslc - INFO - fetching args done.\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - rslc found: \n        date                                 rslc  \\\n0   20210802  ../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../data/gamma/rslc/20221024.rslc   \n\n                                        par  \n0   ../../data/gamma/rslc/20210802.rslc.par  \n1   ../../data/gamma/rslc/20210816.rslc.par  \n2   ../../data/gamma/rslc/20210830.rslc.par  \n3   ../../data/gamma/rslc/20210913.rslc.par  \n4   ../../data/gamma/rslc/20211011.rslc.par  \n5   ../../data/gamma/rslc/20211025.rslc.par  \n6   ../../data/gamma/rslc/20220606.rslc.par  \n7   ../../data/gamma/rslc/20220620.rslc.par  \n8   ../../data/gamma/rslc/20220704.rslc.par  \n9   ../../data/gamma/rslc/20220718.rslc.par  \n10  ../../data/gamma/rslc/20220801.rslc.par  \n11  ../../data/gamma/rslc/20220815.rslc.par  \n12  ../../data/gamma/rslc/20220829.rslc.par  \n13  ../../data/gamma/rslc/20220912.rslc.par  \n14  ../../data/gamma/rslc/20220926.rslc.par  \n15  ../../data/gamma/rslc/20221010.rslc.par  \n16  ../../data/gamma/rslc/20221024.rslc.par  \n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - number of images: 17.\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - image width: 1834.\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par /tmp/tmp0h9aq99y/20220620_20210802.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:14 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par /tmp/tmp0h9aq99y/20220620_20210802.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20210802.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:15 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par /tmp/tmp0h9aq99y/20220620_20210816.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:15 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par /tmp/tmp0h9aq99y/20220620_20210816.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20210816.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:16 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par /tmp/tmp0h9aq99y/20220620_20210830.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:16 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par /tmp/tmp0h9aq99y/20220620_20210830.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20210830.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:17 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par /tmp/tmp0h9aq99y/20220620_20210913.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:17 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par /tmp/tmp0h9aq99y/20220620_20210913.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20210913.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:19 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par /tmp/tmp0h9aq99y/20220620_20211011.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:19 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par /tmp/tmp0h9aq99y/20220620_20211011.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20211011.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:20 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par /tmp/tmp0h9aq99y/20220620_20211025.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:20 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par /tmp/tmp0h9aq99y/20220620_20211025.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20211025.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:21 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par /tmp/tmp0h9aq99y/20220620_20220606.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:21 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par /tmp/tmp0h9aq99y/20220620_20220606.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220606.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:22 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par /tmp/tmp0h9aq99y/20220620_20220620.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:22 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par /tmp/tmp0h9aq99y/20220620_20220620.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220620.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:23 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par /tmp/tmp0h9aq99y/20220620_20220704.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:23 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par /tmp/tmp0h9aq99y/20220620_20220704.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220704.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:25 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par /tmp/tmp0h9aq99y/20220620_20220718.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:25 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par /tmp/tmp0h9aq99y/20220620_20220718.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220718.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:26 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par /tmp/tmp0h9aq99y/20220620_20220801.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:26 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par /tmp/tmp0h9aq99y/20220620_20220801.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220801.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:27 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par /tmp/tmp0h9aq99y/20220620_20220815.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:27 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par /tmp/tmp0h9aq99y/20220620_20220815.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220815.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:29 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par /tmp/tmp0h9aq99y/20220620_20220829.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:29 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par /tmp/tmp0h9aq99y/20220620_20220829.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220829.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par /tmp/tmp0h9aq99y/20220620_20220912.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:30 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par /tmp/tmp0h9aq99y/20220620_20220912.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220912.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:31 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par /tmp/tmp0h9aq99y/20220620_20220926.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:31 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par /tmp/tmp0h9aq99y/20220620_20220926.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20220926.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:33 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par /tmp/tmp0h9aq99y/20220620_20221010.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:33 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par /tmp/tmp0h9aq99y/20220620_20221010.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20221010.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:34 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par /tmp/tmp0h9aq99y/20220620_20221024.off 1 1 1 0 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:34 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par /tmp/tmp0h9aq99y/20220620_20221024.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp0h9aq99y/20220620_20221024.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp0h9aq99y/log\n2023-10-12 23:16:35 - de_load_gamma_flatten_rslc - INFO - gamma command finished.\n2023-10-12 23:16:35 - de_load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2023-10-12 23:16:35 - de_load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2023-10-12 23:16:37 - de_load_gamma_flatten_rslc - INFO - dask local cluster started.\n2023-10-12 23:16:37 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array shape: (2500, 1834, 17)\n2023-10-12 23:16:37 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array chunksize: (1000, 1834, 1)\n2023-10-12 23:16:37 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array dtype: complex64\n2023-10-12 23:16:38 - de_load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2023-10-12 23:16:39 - de_load_gamma_flatten_rslc - INFO - computing finished.\n2023-10-12 23:16:39 - de_load_gamma_flatten_rslc - INFO - dask cluster closed.\n\n\n\n!de_load_gamma_flatten_rslc -h\n\nusage: de_load_gamma_flatten_rslc [-h] [--az_chunk_size AZ_CHUNK_SIZE]\n                                  [--log LOG]\n                                  rslc_dir reference hgt rslc_zarr\n\nGenerate flatten rslc data from gamma command and convert them into zarr format.\nThe shape of hgt should be same as one rslc image, i.e. the hgt file is\ngenerated with 1 by 1 look geocoding.\n\npositional arguments:\n  rslc_dir                       gamma rslc directory, the name of the rslc and\n                                 their par files should be '????????.rslc' and\n                                 '????????.rslc.par'\n  reference                      reference date, eg: '20200202'\n  hgt                            the DEM in radar coordinate\n  rslc_zarr                      output, the flattened rslcs stack in zarr\n                                 format\n\noptions:\n  -h, --help                     show this help message and exit\n  --az_chunk_size AZ_CHUNK_SIZE  rslcs stack azimuth chunk size, azimuth number\n                                 of lines by default (one chunk) (default: -1)\n  --log LOG                      logfile, no log by default\n\n\n\nsource\n\n\nde_load_gamma_lat_lon_hgt\n\n de_load_gamma_lat_lon_hgt (diff_par:str, rslc_par:str, dem_par:str,\n                            hgt:str, lat_zarr:str, lon_zarr:str,\n                            hgt_zarr:str, az_chunk_size:int=-1,\n                            log:str=None)\n\nFunction to load longitude and latitude from gamma binary format to zarr.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndiff_par\nstr\n\ngeocoding diff_par,using the simulated image as reference\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\nhgt\nstr\n\nDEM in radar coordinate\n\n\nlat_zarr\nstr\n\noutput, latitude zarr\n\n\nlon_zarr\nstr\n\noutput, longitude zarr\n\n\nhgt_zarr\nstr\n\noutput, height zarr\n\n\naz_chunk_size\nint\n-1\nazimuth chunk size of lat and lon zarr, azimuth number of lines by default (one chunk)\n\n\nlog\nstr\nNone\nlogfile, no log by default\n\n\n\n\ndiff_par = '../../data/gamma/geocoding/20210802.diff_par'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nlat_zarr = './raw/lat.zarr'\nlon_zarr = './raw/lon.zarr'\nhgt_zarr = './raw/hgt.zarr'\naz_chunk_size = 1000\n\nAn example:\n\nde_load_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,lat_zarr,lon_zarr,hgt_zarr,az_chunk_size)\n\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - fetching args:\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - diff_par = '../../data/gamma/geocoding/20210802.diff_par'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - lat_zarr = './raw/lat.zarr'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - lon_zarr = './raw/lon.zarr'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - hgt_zarr = './raw/hgt.zarr'\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - az_chunk_size = 1000\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - log = None\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - fetching args done.\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2023-10-12 23:13:14 - de_load_gamma_lat_lon_hgt - INFO - run command: pt2geo /tmp/tmpl3gnphh9/plist - ../../data/gamma/rslc/20220620.rslc.par - ../../data/gamma/geocoding/20210802.hgt ../../data/gamma/DEM/dem_seg_par ../../data/gamma/geocoding/20210802.diff_par 1 1 - - /tmp/tmpl3gnphh9/plat_lon /tmp/tmpl3gnphh9/phgt_wgs84 &gt; /tmp/tmpl3gnphh9/log\n2023-10-12 23:13:26 - de_load_gamma_lat_lon_hgt - INFO - gamma command finished.\n2023-10-12 23:13:26 - de_load_gamma_lat_lon_hgt - INFO - Done.\n\n\n\nlon_data = zarr.open(lon_zarr,mode='r')[:]\nlat_data = zarr.open(lat_zarr,mode='r')[:]\nhgt_data = zarr.open(hgt_zarr,mode='r')[:]\n\nlon_data[lon_data==0] = np.nan\nlat_data[lat_data==0] = np.nan\nhgt_data[hgt_data==0] = np.nan\n\n\nfig,axes = plt.subplots(1,3,figsize=(16,5))\nim0 = axes[0].imshow(lon_data)\naxes[0].set_title('Longitude')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(lat_data)\naxes[1].set_title('Latitude')\nfig.colorbar(im1, ax=axes[1])\nim2 = axes[2].imshow(hgt_data)\naxes[2].set_title('Height')\nfig.colorbar(im2, ax=axes[2])\nfig.show()\n\n\n\n\n\n!de_load_gamma_lat_lon_hgt -h\n\nusage: de_load_gamma_lat_lon_hgt [-h] [--az_chunk_size AZ_CHUNK_SIZE]\n                                 [--log LOG]\n                                 diff_par rslc_par dem_par hgt lat_zarr lon_zarr\n                                 hgt_zarr\n\nFunction to load longitude and latitude from gamma binary format to zarr.\n\npositional arguments:\n  diff_par                       geocoding diff_par,using the simulated image as\n                                 reference\n  rslc_par                       par file of the reference rslc\n  dem_par                        dem par\n  hgt                            DEM in radar coordinate\n  lat_zarr                       output, latitude zarr\n  lon_zarr                       output, longitude zarr\n  hgt_zarr                       output, height zarr\n\noptions:\n  -h, --help                     show this help message and exit\n  --az_chunk_size AZ_CHUNK_SIZE  azimuth chunk size of lat and lon zarr, azimuth\n                                 number of lines by default (one chunk)\n                                 (default: -1)\n  --log LOG                      logfile, no log by default\n\n\n\nsource\n\n\nde_load_gamma_look_vector\n\n de_load_gamma_look_vector (theta:str, phi:str, lt:str, rslc_par:str,\n                            dem_par:str, theta_zarr:str, phi_zarr:str,\n                            az_chunk_size:int=-1, log:str=None)\n\nLoad look vector (elevation angle and orientation angle) in map geometry from gamma binary format to look vector in radar geometry zarr file. The two input data should be generated with the look_vector gamma command.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntheta\nstr\n\nelevation angle\n\n\nphi\nstr\n\norientation angle\n\n\nlt\nstr\n\nlookup table\n\n\nrslc_par\nstr\n\npar file of the reference rslc\n\n\ndem_par\nstr\n\ndem par\n\n\ntheta_zarr\nstr\n\noutput, elevation angle zarr\n\n\nphi_zarr\nstr\n\noutput, orientation angle zarr\n\n\naz_chunk_size\nint\n-1\nazimuth chunk size of lat and lon zarr, azimuth number of lines by default (one chunk)\n\n\nlog\nstr\nNone\nlogfile, no log by default\n\n\n\nAn example:\n\nlt = '../../data/gamma/geocoding/20210802.lt_fine'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\ntheta = '../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../data/gamma/geocoding/20210802.lv_phi'\ntheta_zarr = './raw/theta.zarr'\nphi_zarr = './raw/phi.zarr'\naz_chunk_size = 1000\n\n\nde_load_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,theta_zarr,phi_zarr,az_chunk_size)\n\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - fetching args:\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - theta = '../../data/gamma/geocoding/20210802.lv_theta'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - phi = '../../data/gamma/geocoding/20210802.lv_phi'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - lt = '../../data/gamma/geocoding/20210802.lt_fine'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - theta_zarr = './raw/theta.zarr'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - phi_zarr = './raw/phi.zarr'\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - az_chunk_size = 1000\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - log = None\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - fetching args done.\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - image shape: (2500,1834)\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - run gamma command to generate elevation angle in range doppler coordinate:\n2023-10-12 23:13:30 - de_load_gamma_look_vector - INFO - run command: geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_theta 5741 /tmp/tmp9b97n2gp/theta_rdc 1834 2500 &gt; /tmp/tmp9b97n2gp/log\n2023-10-12 23:13:32 - de_load_gamma_look_vector - INFO - gamma command finished.\n2023-10-12 23:13:32 - de_load_gamma_look_vector - INFO - writing data.\n2023-10-12 23:13:32 - de_load_gamma_look_vector - INFO - run gamma command to generate orientation angle in range doppler coordinate:\n2023-10-12 23:13:32 - de_load_gamma_look_vector - INFO - run command: geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_phi 5741 /tmp/tmp9b97n2gp/phi_rdc 1834 2500 &gt; /tmp/tmp9b97n2gp/log\n2023-10-12 23:13:33 - de_load_gamma_look_vector - INFO - gamma command finished.\n2023-10-12 23:13:33 - de_load_gamma_look_vector - INFO - writing data.\n2023-10-12 23:13:33 - de_load_gamma_look_vector - INFO - Done.\n\n\n\ntheta_data = zarr.open(theta_zarr,mode='r')[:]\nphi_data = zarr.open(phi_zarr,mode='r')[:]\ntheta_data[theta_data==0] = np.nan\nphi_data[phi_data==0] = np.nan\n\n\nfig,axes = plt.subplots(1,2,figsize=(11,5))\nim0 = axes[0].imshow(np.rad2deg(theta_data))\naxes[0].set_title('Elevation angle')\nfig.colorbar(im0, ax=axes[0])\nim1 = axes[1].imshow(np.rad2deg(phi_data))\naxes[1].set_title('Orientation anlge')\nfig.colorbar(im1, ax=axes[1])\nfig.show()\n\n\n\n\n\nsource\n\n\nde_load_gamma_range\n\n de_load_gamma_range (rslc_par:str, range_zarr:str, az_chunk_size:int=-1,\n                      log:str=None)\n\nGenerate slant range distance and save to zarr.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_par\nstr\n\npar file of one rslc\n\n\nrange_zarr\nstr\n\noutput, range distance zarr\n\n\naz_chunk_size\nint\n-1\nazimuth chunk size of lat and lon zarr, azimuth number of lines by default (one chunk)\n\n\nlog\nstr\nNone\nlogfile, no log by default\n\n\n\nAn example:\n\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\nrange_zarr = './raw/range.zarr'\naz_chunk_size = 1000\n\n\nde_load_gamma_range(rslc_par,range_zarr,az_chunk_size)\n\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - fetching args:\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - range_zarr = './raw/range.zarr'\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - az_chunk_size = 1000\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - log = None\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - fetching args done.\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - image shape: (2500,1834)\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - Calculating slant range distance.\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - writing data.\n2023-10-12 23:13:34 - de_load_gamma_range - INFO - Done.\n\n\n\nrange_data = zarr.open(range_zarr,mode='r')[:]\nrange_data[range_data==0] = np.nan\nplt.imshow(range_data)\nplt.colorbar()\nplt.title(\"Slant range distance\")\nplt.show()\n\n\n\n\n\nsource\n\n\nde_load_gamma_metadata\n\n de_load_gamma_metadata (rslc_dir:str, reference:str, meta_file:str,\n                         log:str=None)\n\nLoad necessary metadata into a toml file.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc_dir\nstr\n\n# gamma rslc directory, the name of the rslc and their par files should be ‘????????.rslc’ and ‘????????.rslc.par’\n\n\nreference\nstr\n\nreference date, eg: ‘20200202’\n\n\nmeta_file\nstr\n\ntext toml file for meta data\n\n\nlog\nstr\nNone\nlogfile, no log by default\n\n\n\nAn example:\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nmeta_file = './raw/meta.toml'\n\n\nde_load_gamma_metadata(rslc_dir,reference,meta_file)\n\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - fetching args:\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - reference = '20220620'\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - meta_file = './raw/meta.toml'\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - log = None\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - fetching args done.\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - Fetching heading angle\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - Fetching range pixel spacing\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - Fetching randar wavelength\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2023-10-12 23:13:34 - de_load_gamma_metadata - INFO - run command: base_calc /tmp/tmpqme0aptb/slc_tab ../../data/gamma/rslc/20220620.rslc.par /tmp/tmpqme0aptb/bperp /tmp/tmpqme0aptb/itab - &gt; /tmp/tmpqme0aptb/log\n2023-10-12 23:13:35 - de_load_gamma_metadata - INFO - gamma command finished.\n2023-10-12 23:13:35 - de_load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2023-10-12 23:13:35 - de_load_gamma_metadata - INFO - writing data in toml file.\n2023-10-12 23:13:35 - de_load_gamma_metadata - INFO - Done.\n\n\n\nwith open(meta_file,'r') as f:\n    meta_read = toml.load(f)\n\n\nmeta_read\n\n{'dates': ['20210802',\n  '20210816',\n  '20210830',\n  '20210913',\n  '20211011',\n  '20211025',\n  '20220606',\n  '20220620',\n  '20220704',\n  '20220718',\n  '20220801',\n  '20220815',\n  '20220829',\n  '20220912',\n  '20220926',\n  '20221010',\n  '20221024'],\n 'radar_wavelength': 0.24245249210715603,\n 'range_pixel_spacing': 4.29054,\n 'azimuth_pixel_spacing': 3.740105,\n 'perpendicular_baseline': [-97.61360168457031,\n  -45.58580017089844,\n  17.86680030822754,\n  -26.258899688720703,\n  -63.72420120239258,\n  -56.363399505615234,\n  64.75759887695312,\n  0.0,\n  -9.043999671936035,\n  -13.02869987487793,\n  -112.94960021972656,\n  -86.09490203857422,\n  -129.9635009765625,\n  -127.6594009399414,\n  -182.29519653320312,\n  -129.735107421875,\n  -184.31100463867188]}"
  },
  {
    "objectID": "CLI/co.html",
    "href": "CLI/co.html",
    "title": "co",
    "section": "",
    "text": "source\n\nde_emperical_co_pc\n\n de_emperical_co_pc (rslc:str, ds_can_is_shp:str, ds_can_idx:str,\n                     ds_can_coh:str, az_chunk_size:int=None,\n                     n_pc_chunk:int=None, pc_chunk_size:int=None,\n                     ds_can_coh_ave_fig:str=None, log=None)\n\nestimate emperical coherence matrix on point cloud data. Only one of n_pc_chunk and pc_chunk_size needs to be setted. The other one is automatically determined. If all of them are not setted, the n_pc_chunk will be setted as the number of azimuth chunks.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack\n\n\nds_can_is_shp\nstr\n\ninput: bool array indicating the SHPs of every pixel\n\n\nds_can_idx\nstr\n\ninput: bool array indicating DS candidate\n\n\nds_can_coh\nstr\n\noutput: complex coherence matrix for DS candidate\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, optional. Default: the azimuth chunk size in rslc stack\n\n\nn_pc_chunk\nint\nNone\nnumber of point chunk, optional.\n\n\npc_chunk_size\nint\nNone\nchunk size of output zarr dataset, optional. Default: same as ds_can_is_shp\n\n\nds_can_coh_ave_fig\nstr\nNone\npath to the plot of average coherence matrix of DS candidate, optional. Default: no plot\n\n\nlog\nNoneType\nNone\nlog file. Default: no log file\n\n\n\n\nrslc = './raw/rslc.zarr'\nds_can_is_shp = './shp/ds_can_is_shp.zarr'\nds_can_idx = './shp/ds_can_idx.zarr'\nds_can_coh = './co/ds_can_coh.zarr'\naz_chunk_size = 1000\npc_chunk_size = None\nlog = './co/co.log'\nds_can_coh_ave_fig = './co/ds_can_coh_ave.png'\n\n\nde_emperical_co_pc(rslc,ds_can_is_shp,ds_can_idx,ds_can_coh,log=log,ds_can_coh_ave_fig=ds_can_coh_ave_fig)\n\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - fetching args:\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - rslc = './raw/rslc.zarr'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ds_can_is_shp = './shp/ds_can_is_shp.zarr'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ds_can_idx = './shp/ds_can_idx.zarr'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ds_can_coh = './co/ds_can_coh.zarr'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - az_chunk_size = None\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - n_pc_chunk = None\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - pc_chunk_size = None\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ds_can_coh_ave_fig = './co/ds_can_coh_ave.png'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - log = './co/co.log'\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - fetching args done.\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./raw/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./raw/rslc.zarr zarray chunks: (1000, 1834, 1)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./raw/rslc.zarr zarray dtype: complex64\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_is_shp.zarr zarray shape: (740397, 11, 11)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_is_shp.zarr zarray chunks: (1000, 11, 11)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_is_shp.zarr zarray dtype: bool\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_idx.zarr zarray chunks: (2, 1000)\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - ./shp/ds_can_idx.zarr zarray dtype: int64\n2023-10-13 20:49:21 - de_emperical_co_pc - INFO - loading ds_can_idx into memory.\n2023-10-13 20:49:22 - de_emperical_co_pc - INFO - got azimuth window size and half azimuth window size from is_shp shape: 11, 5\n2023-10-13 20:49:22 - de_emperical_co_pc - INFO - got range window size and half range window size from is_shp shape: 11, 5\n2023-10-13 20:49:22 - de_emperical_co_pc - INFO - using default parallel processing azimuth chunk size from rslc dataset.\n2023-10-13 20:49:22 - de_emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 20:49:22 - de_emperical_co_pc - INFO - starting dask CUDA local cluster.\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - dask local CUDA cluster started.\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - create raster bool array is_ds_can from ds_can_idx\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - create dask bool array is_ds_can\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can dask array shape: (2500, 1834)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can dask array chunksize: (1000, 1834)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can dask array dtype: bool\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - Using azimuth chunk size as the processing chunk size.\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - Calculate point chunk size\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - Point chunk size: (346329, 274921, 119147)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc dask array dtype: complex64\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - ds_can_is_shp dask array chunksize: (346329, 11, 11)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - setting shared boundaries between rlsc chunks.\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc_overlap dask array shape: (2520, 1834, 17)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc_overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - rslc_overlap dask array dtype: complex64\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - padding zero between is_ds_can chunks.\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can_padded dask array shape: (2520, 1834)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can_padded dask array chunksize: (1010, 1834)\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - is_ds_can_padded dask array dtype: bool\n2023-10-13 20:49:30 - de_emperical_co_pc - INFO - estimating coherence matrix.\n2023-10-13 20:49:31 - de_emperical_co_pc - INFO - got coherence matrix.\n2023-10-13 20:49:31 - de_emperical_co_pc - INFO - set pc_chunk_size as az_chunk_size: 1000\n2023-10-13 20:49:31 - de_emperical_co_pc - INFO - rechunking ds_can_coh to chunk size (for saving with zarr): (1000, 17, 17)\n2023-10-13 20:49:31 - de_emperical_co_pc - INFO - saving ds_can_coh.\n2023-10-13 20:49:31 - de_emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2023-10-13 20:50:00 - de_emperical_co_pc - INFO - computing finished.\n2023-10-13 20:50:01 - de_emperical_co_pc - INFO - dask cluster closed.\nCPU times: user 3.56 s, sys: 2.67 s, total: 6.23 s\nWall time: 39.8 s\n\n\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,974 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,979 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,980 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,980 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,980 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:49:24,981 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:49:24,982 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\n\n!de_emperical_co_pc -h\n\nusage: de_emperical_co_pc [-h] [--az_chunk_size AZ_CHUNK_SIZE]\n                          [--n_pc_chunk N_PC_CHUNK]\n                          [--pc_chunk_size PC_CHUNK_SIZE]\n                          [--ds_can_coh_ave_fig DS_CAN_COH_AVE_FIG] [--log LOG]\n                          rslc ds_can_is_shp ds_can_idx ds_can_coh\n\nestimate emperical coherence matrix on point cloud data. Only one of\n`n_pc_chunk` and `pc_chunk_size` needs to be setted. The other one is\nautomatically determined. If all of them are not setted, the `n_pc_chunk` will\nbe setted as the number of azimuth chunks.\n\npositional arguments:\n  rslc                                  input: rslc stack\n  ds_can_is_shp                         input: bool array indicating the SHPs of\n                                        every pixel\n  ds_can_idx                            input: bool array indicating DS\n                                        candidate\n  ds_can_coh                            output: complex coherence matrix for DS\n                                        candidate\n\noptions:\n  -h, --help                            show this help message and exit\n  --az_chunk_size AZ_CHUNK_SIZE         azimuth chunk size, optional. Default:\n                                        the azimuth chunk size in rslc stack\n  --n_pc_chunk N_PC_CHUNK               number of point chunk, optional.\n  --pc_chunk_size PC_CHUNK_SIZE         chunk size of output zarr dataset,\n                                        optional. Default: same as ds_can_is_shp\n  --ds_can_coh_ave_fig DS_CAN_COH_AVE_FIG\n                                        path to the plot of average coherence\n                                        matrix of DS candidate, optional.\n                                        Default: no plot\n  --log LOG                             log file. Default: no log file"
  },
  {
    "objectID": "CLI/utils/dask.html",
    "href": "CLI/utils/dask.html",
    "title": "dask",
    "section": "",
    "text": "source\n\npad_internal\n\n pad_internal (arr:&lt;function array&gt;, depth:dict=None)\n\nPad zero between block boundaries, currently one pad zero are supported\n\nsource\n\n\nget_cuda_cluster\n\n get_cuda_cluster ()\n\n\nsource\n\n\nget_pc_chunk_size\n\n get_pc_chunk_size (az_chunk_size, pc_size, pc_chunk_size=None,\n                    n_pc_chunk=None, logger=None)\n\nautomatically determine pc_chunk_size, n_pc_chunk."
  },
  {
    "objectID": "CLI/utils/appconfig.html",
    "href": "CLI/utils/appconfig.html",
    "title": "appconfig",
    "section": "",
    "text": "source\n\nget_config\n\n get_config (appname='decorrelation')"
  },
  {
    "objectID": "CLI/utils/logging.html",
    "href": "CLI/utils/logging.html",
    "title": "logging",
    "section": "",
    "text": "source\n\nzarr_info\n\n zarr_info (path, zarr)\n\n\n\n\n\nDetails\n\n\n\n\npath\nstring to zarr\n\n\nzarr\nzarr dataset\n\n\n\n\nsource\n\n\ndarr_info\n\n darr_info (name, darr)\n\n\n\n\n\nDetails\n\n\n\n\nname\nprinting name of the dask array\n\n\ndarr\ndask array\n\n\n\n\nsource\n\n\nget_logger\n\n get_logger (name:str=None, logfile:str=None, level:str=None)\n\nget logger for decorrelation cli application\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nNone\nname of the application, optional. default: the function name that call this function\n\n\nlogfile\nstr\nNone\nlogfile, optional. default: no logfile\n\n\nlevel\nstr\nNone\nlog level, debug or info, optional. default: info\n\n\n\n\nsource\n\n\nlog_args\n\n log_args (func)\n\n\ndef log_test():\n    logger = get_logger(logfile='test.log')\n    rslc_path = '../raw/rslc.zarr/'\n    rslc_zarr = zarr.open(rslc_path,'r')\n    logger.zarr_info(rslc_path,rslc_zarr)\n    rslc_darr = da.from_zarr(rslc_path)\n    logger.darr_info('rslc',rslc_darr)\n    logger.debug(\"This is a debug log.\")\n    logger.info(\"This is a info log.\")\n    logger.warning(\"This is a warning log.\")\n    logger.error(\"This is a error log.\")\n    logger.critical(\"This is a critical log.\")\n\n\nlog_test()\n\n2023-10-10 17:24:40 - log_test - INFO - ../raw/rslc.zarr/ zarray shape: (2500, 1834, 17)\n2023-10-10 17:24:40 - log_test - INFO - ../raw/rslc.zarr/ zarray chunks: (1000, 1834, 1)\n2023-10-10 17:24:40 - log_test - INFO - ../raw/rslc.zarr/ zarray dtype: complex64\n2023-10-10 17:24:40 - log_test - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-10-10 17:24:40 - log_test - INFO - rslc dask array chunksize: (1000, 1834, 1)\n2023-10-10 17:24:40 - log_test - INFO - rslc dask array dtype: complex64\n2023-10-10 17:24:40 - log_test - INFO - This is a info log.\n2023-10-10 17:24:40 - log_test - WARNING - This is a warning log.\n2023-10-10 17:24:40 - log_test - ERROR - This is a error log.\n2023-10-10 17:24:40 - log_test - CRITICAL - This is a critical log."
  },
  {
    "objectID": "CLI/shp.html",
    "href": "CLI/shp.html",
    "title": "shp",
    "section": "",
    "text": "source\n\nde_shp_test\n\n de_shp_test (rslc:str, pvalue:str, az_half_win:int, r_half_win:int,\n              method:str=None, az_chunk_size:int=None, log:str=None)\n\nSHP identification through hypothetic test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nstr\n\ninput: rslc stack\n\n\npvalue\nstr\n\noutput: the p value of the test\n\n\naz_half_win\nint\n\nazimuth half window size\n\n\nr_half_win\nint\n\nrange half window size\n\n\nmethod\nstr\nNone\nSHP identification method,optional. Default: ks\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, optional. Default: the azimuth chunk size in rslc\n\n\nlog\nstr\nNone\nlog file, optional. Default: no log file\n\n\n\nThis function is a wrapper of functions in decorrelation.shp that provides file interface. Please refer it for the usage. It utilizes dask for parallel and distributed computation. Compared with the functions in decorrelation.shp, this function splits the dataset into several chunks and the computation in these chunks can run in parallel on multi-GPUs.\nThe r_chunk_size and az_chunk_size is used to determine how many pixels in range and azimuth in one chunk. The chunk size of the output pvalue is also setted according to them.\n\n# rslc = '../../data/rslc.zarr'\nrslc = './raw/rslc.zarr'\npvalue = './shp/pvalue.zarr'\n\n\nde_shp_test(rslc,pvalue,az_half_win=5,r_half_win=5, method=None,az_chunk_size=1000,log='./shp/de_shp_test.log')\n\n2023-10-13 20:48:22 - de_shp_test - INFO - fetching args:\n2023-10-13 20:48:22 - de_shp_test - INFO - rslc = './raw/rslc.zarr'\n2023-10-13 20:48:22 - de_shp_test - INFO - pvalue = './shp/pvalue.zarr'\n2023-10-13 20:48:22 - de_shp_test - INFO - az_half_win = 5\n2023-10-13 20:48:22 - de_shp_test - INFO - r_half_win = 5\n2023-10-13 20:48:22 - de_shp_test - INFO - method = None\n2023-10-13 20:48:22 - de_shp_test - INFO - az_chunk_size = 1000\n2023-10-13 20:48:22 - de_shp_test - INFO - log = './shp/de_shp_test.log'\n2023-10-13 20:48:22 - de_shp_test - INFO - fetching args done.\n2023-10-13 20:48:22 - de_shp_test - INFO - hypothetic test method: ks\n2023-10-13 20:48:22 - de_shp_test - INFO - ./raw/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-10-13 20:48:22 - de_shp_test - INFO - ./raw/rslc.zarr zarray chunks: (1000, 1834, 1)\n2023-10-13 20:48:22 - de_shp_test - INFO - ./raw/rslc.zarr zarray dtype: complex64\n2023-10-13 20:48:22 - de_shp_test - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 20:48:22 - de_shp_test - INFO - starting dask CUDA local cluster.\n2023-10-13 20:48:30 - de_shp_test - INFO - dask local CUDA cluster started.\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc dask array dtype: complex64\n2023-10-13 20:48:30 - de_shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2023-10-13 20:48:30 - de_shp_test - INFO - range half window size: 5; range window size: 11\n2023-10-13 20:48:30 - de_shp_test - INFO - setting shared boundaries between rlsc chunks.\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc with overlap dask array shape: (2520, 1834, 17)\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc with overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 20:48:30 - de_shp_test - INFO - rslc with overlap dask array dtype: complex64\n2023-10-13 20:48:31 - de_shp_test - INFO - rmli with overlap dask array shape: (2520, 1834, 17)\n2023-10-13 20:48:31 - de_shp_test - INFO - rmli with overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 20:48:31 - de_shp_test - INFO - rmli with overlap dask array dtype: float32\n2023-10-13 20:48:31 - de_shp_test - INFO - applying test on sorted rmli stack.\n2023-10-13 20:48:31 - de_shp_test - INFO - p value generated\n2023-10-13 20:48:31 - de_shp_test - INFO - p value dask array shape: (2520, 1834, 11, 11)\n2023-10-13 20:48:31 - de_shp_test - INFO - p value dask array chunksize: (1010, 1834, 11, 11)\n2023-10-13 20:48:31 - de_shp_test - INFO - p value dask array dtype: float32\n2023-10-13 20:48:31 - de_shp_test - INFO - trim shared boundaries between p value chunks\n2023-10-13 20:48:31 - de_shp_test - INFO - trimmed p value dask array shape: (2500, 1834, 11, 11)\n2023-10-13 20:48:31 - de_shp_test - INFO - trimmed p value dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 20:48:31 - de_shp_test - INFO - trimmed p value dask array dtype: float32\n2023-10-13 20:48:31 - de_shp_test - INFO - saving p value.\n2023-10-13 20:48:31 - de_shp_test - INFO - computing graph setted. doing all the computing.\n2023-10-13 20:48:36 - de_shp_test - INFO - computing finished.\n2023-10-13 20:48:37 - de_shp_test - INFO - dask cluster closed.\nCPU times: user 883 ms, sys: 1.75 s, total: 2.63 s\nWall time: 15.3 s\n\n\n2023-10-13 20:48:24,981 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,981 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:24,982 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,982 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:24,993 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,993 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:24,994 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,994 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:24,995 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,995 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:24,996 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:24,996 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:25,004 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:25,004 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 20:48:25,017 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 20:48:25,017 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\nThis function can also be called from command line directly:\n\n!de_shp_test -h\n\nusage: de_shp_test [-h] [--method METHOD] [--az_chunk_size AZ_CHUNK_SIZE]\n                   [--log LOG]\n                   rslc pvalue az_half_win r_half_win\n\nSHP identification through hypothetic test.\n\npositional arguments:\n  rslc                           input: rslc stack\n  pvalue                         output: the p value of the test\n  az_half_win                    azimuth half window size\n  r_half_win                     range half window size\n\noptions:\n  -h, --help                     show this help message and exit\n  --method METHOD                SHP identification method,optional. Default: ks\n  --az_chunk_size AZ_CHUNK_SIZE  azimuth chunk size, optional. Default: the\n                                 azimuth chunk size in rslc\n  --log LOG                      log file, optional. Default: no log file\n\n\n\nsource\n\n\nde_select_ds_can\n\n de_select_ds_can (pvalue:str, ds_can_idx:str, ds_can_is_shp:str,\n                   p_max:float=0.05, shp_num_min:int=50,\n                   az_chunk_size:int=None, n_pc_chunk:int=None,\n                   pc_chunk_size:int=None, shp_num_fig:str=None,\n                   is_ds_can_fig:str=None, log=None)\n\nSelect DS candidate based on pvalue of SHP test. Only one of n_pc_chunk and pc_chunk_size needs to be setted. The other one is automatically determined. If all of them are not setted, the n_pc_chunk will be setted as the number of azimuth chunks.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npvalue\nstr\n\ninput: pvalue of hypothetic test\n\n\nds_can_idx\nstr\n\noutput: index array of DS candidate\n\n\nds_can_is_shp\nstr\n\noutput: bool array indicating the SHPs of DS candidate\n\n\np_max\nfloat\n0.05\nthreshold of p value to select SHP,optional. Default: 0.05\n\n\nshp_num_min\nint\n50\nthreshold of number of SHPs to select DS candidate,optional. Default: 50\n\n\naz_chunk_size\nint\nNone\nazimuth chunk size, optional. Default: the azimuth chunk size in pvalue\n\n\nn_pc_chunk\nint\nNone\nnumber of point target chunks, optional.\n\n\npc_chunk_size\nint\nNone\npoint target chunk size, optional.\n\n\nshp_num_fig\nstr\nNone\npath to the plot of number of SHPs, optional. Default: no plot\n\n\nis_ds_can_fig\nstr\nNone\npath to the plot of DSs candidate distribution, optional. Default: no plot\n\n\nlog\nNoneType\nNone\nlog file. Default: no log file\n\n\n\n\npvalue = './shp/pvalue.zarr'\nds_can_idx = './shp/ds_can_idx.zarr'\nds_can_is_shp = './shp/ds_can_is_shp.zarr'\nshp_num_fig = './shp/shp_num_fig.png'\nis_ds_can_fig = './shp/is_ds_can.png'\naz_chunk_size = 1000\np_max = 0.05\nshp_num_min=50\n\n\nde_select_ds_can(pvalue,ds_can_idx,ds_can_is_shp,p_max=p_max,shp_num_min=shp_num_min,\n                 az_chunk_size=az_chunk_size,shp_num_fig=shp_num_fig,is_ds_can_fig=is_ds_can_fig)\n\n2023-10-13 20:48:40 - de_select_ds_can - INFO - fetching args:\n2023-10-13 20:48:40 - de_select_ds_can - INFO - pvalue = './shp/pvalue.zarr'\n2023-10-13 20:48:40 - de_select_ds_can - INFO - ds_can_idx = './shp/ds_can_idx.zarr'\n2023-10-13 20:48:40 - de_select_ds_can - INFO - ds_can_is_shp = './shp/ds_can_is_shp.zarr'\n2023-10-13 20:48:40 - de_select_ds_can - INFO - p_max = 0.05\n2023-10-13 20:48:40 - de_select_ds_can - INFO - shp_num_min = 50\n2023-10-13 20:48:40 - de_select_ds_can - INFO - az_chunk_size = 1000\n2023-10-13 20:48:40 - de_select_ds_can - INFO - n_pc_chunk = None\n2023-10-13 20:48:40 - de_select_ds_can - INFO - pc_chunk_size = None\n2023-10-13 20:48:40 - de_select_ds_can - INFO - shp_num_fig = './shp/shp_num_fig.png'\n2023-10-13 20:48:40 - de_select_ds_can - INFO - is_ds_can_fig = './shp/is_ds_can.png'\n2023-10-13 20:48:40 - de_select_ds_can - INFO - log = None\n2023-10-13 20:48:40 - de_select_ds_can - INFO - fetching args done.\n2023-10-13 20:48:40 - de_select_ds_can - INFO - ./shp/pvalue.zarr zarray shape: (2500, 1834, 11, 11)\n2023-10-13 20:48:40 - de_select_ds_can - INFO - ./shp/pvalue.zarr zarray chunks: (1000, 1834, 11, 11)\n2023-10-13 20:48:40 - de_select_ds_can - INFO - ./shp/pvalue.zarr zarray dtype: float32\n2023-10-13 20:48:40 - de_select_ds_can - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 20:48:40 - de_select_ds_can - INFO - starting dask local cluster.\n2023-10-13 20:48:42 - de_select_ds_can - INFO - dask local cluster started.\n2023-10-13 20:48:42 - de_select_ds_can - INFO - pvalue dask array shape: (2500, 1834, 11, 11)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - pvalue dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - pvalue dask array dtype: float32\n2023-10-13 20:48:42 - de_select_ds_can - INFO - selecting SHPs based on pvalue threshold: 0.05\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_shp dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_shp dask array dtype: bool\n2023-10-13 20:48:42 - de_select_ds_can - INFO - selecting DS candidates based on minimum of number of SHPs: 50\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_ds_can dask array shape: (2500, 1834)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_ds_can dask array chunksize: (1000, 1834)\n2023-10-13 20:48:42 - de_select_ds_can - INFO - is_ds_can dask array dtype: bool\n2023-10-13 20:48:42 - de_select_ds_can - INFO - calculate ds_can index:\n2023-10-13 20:48:42 - de_select_ds_can - INFO - slice is_shp on ds_can index:\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array shape: (2, 740397)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array chunksize: (1, 346329)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array dtype: int64\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array chunksize: (346329, 11, 11)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 20:48:46 - de_select_ds_can - INFO - set pc_chunk_size as az_chunk_size: 1000\n2023-10-13 20:48:46 - de_select_ds_can - INFO - rechunk ds_can_idx and ds_can_is_shp:\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array shape: (2, 740397)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array chunksize: (2, 1000)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_idx dask array dtype: int64\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array chunksize: (1000, 11, 11)\n2023-10-13 20:48:46 - de_select_ds_can - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 20:48:47 - de_select_ds_can - INFO - saving ds_can_is_shp.\n2023-10-13 20:48:47 - de_select_ds_can - INFO - saving ds_can_idx.\n2023-10-13 20:48:47 - de_select_ds_can - INFO - computing graph setted. doing all the computing.\n2023-10-13 20:48:53 - de_select_ds_can - INFO - computing finished.\n2023-10-13 20:48:53 - de_select_ds_can - INFO - dask cluster closed.\n2023-10-13 20:48:53 - de_select_ds_can - INFO - plotting number of SHPs.\n2023-10-13 20:48:54 - de_select_ds_can - INFO - plotting DS candidate distribution.\nCPU times: user 3.52 s, sys: 1.52 s, total: 5.04 s\nWall time: 13.9 s\n\n\n\n\n\n\n\n\n\n!de_select_ds_can -h\n\nusage: de_select_ds_can [-h] [--p_max P_MAX] [--shp_num_min SHP_NUM_MIN]\n                        [--az_chunk_size AZ_CHUNK_SIZE]\n                        [--n_pc_chunk N_PC_CHUNK]\n                        [--pc_chunk_size PC_CHUNK_SIZE]\n                        [--shp_num_fig SHP_NUM_FIG]\n                        [--is_ds_can_fig IS_DS_CAN_FIG] [--log LOG]\n                        pvalue ds_can_idx ds_can_is_shp\n\nSelect DS candidate based on pvalue of SHP test. Only one of `n_pc_chunk` and\n`pc_chunk_size` needs to be setted. The other one is automatically determined.\nIf all of them are not setted, the `n_pc_chunk` will be setted as the number of\nazimuth chunks.\n\npositional arguments:\n  pvalue                         input: pvalue of hypothetic test\n  ds_can_idx                     output: index array of DS candidate\n  ds_can_is_shp                  output: bool array indicating the SHPs of DS\n                                 candidate\n\noptions:\n  -h, --help                     show this help message and exit\n  --p_max P_MAX                  threshold of p value to select SHP,optional.\n                                 Default: 0.05 (default: 0.05)\n  --shp_num_min SHP_NUM_MIN      threshold of number of SHPs to select DS\n                                 candidate,optional. Default: 50 (default: 50)\n  --az_chunk_size AZ_CHUNK_SIZE  azimuth chunk size, optional. Default: the\n                                 azimuth chunk size in pvalue\n  --n_pc_chunk N_PC_CHUNK        number of point target chunks, optional.\n  --pc_chunk_size PC_CHUNK_SIZE  point target chunk size, optional.\n  --shp_num_fig SHP_NUM_FIG      path to the plot of number of SHPs, optional.\n                                 Default: no plot\n  --is_ds_can_fig IS_DS_CAN_FIG  path to the plot of DSs candidate distribution,\n                                 optional. Default: no plot\n  --log LOG                      log file. Default: no log file"
  },
  {
    "objectID": "Introduction/software_architecture.html",
    "href": "Introduction/software_architecture.html",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Decorrelation only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Decorrelation is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Decorrelation provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Decorrelation, the input and output are well explained in the documentation of every Decorrelation functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity."
  },
  {
    "objectID": "Introduction/software_architecture.html#software-design",
    "href": "Introduction/software_architecture.html#software-design",
    "title": "Software Architecture",
    "section": "",
    "text": "Unlike most InSAR processing software (e.g., StamPS, MintPy) that have designated processing workflow, Decorrelation only provides a collection of Python functions or commands. The reason is, in real application, there is no perfect workflow that always generate satisfactory deformation result. Especially when the coherence is not good and atmospheric artifact is strong. One needs to try a lot of different methods but they are generally implented in different packages. Even worse, the workflow-based software are encapsulated too much and generally no detailed documentation is provided. It is really frustrating when users need to save intermediate data from one software and prepared them in a designated format and structure required by another software. Sometimes it is necessarry to read a lot of source code to understand what are the output, what are their data structure and what kind of inputs are needed as their typical workflows is not followed. So, instead of providing a standard workflow, Decorrelation is designed as a collection of functions that implement specific InSAR processing techniques (e.g. calculate the dispersion index, do phase linking) and users are encouraged to make their own workflow that are suitable for their case. We provide the necessary infrastructure and your role is to be innovative! To make it easier, Decorrelation provides detailed documentation for each function that explain the usage. We also provide the tutorials section that provide some typical workflow for your reference. In case users want to try methods that are not implemented in Decorrelation, the input and output are well explained in the documentation of every Decorrelation functions.\nAlthough we provide detailed documentation and reference workflow, we still admit this software is not that easy that users only need to run from the first step to the last step. It doesn’t mean we don’t value user-friendliness, but it shouldn’t come at the expense of flexibility and creativity."
  },
  {
    "objectID": "Introduction/software_architecture.html#software-structure",
    "href": "Introduction/software_architecture.html#software-structure",
    "title": "Software Architecture",
    "section": "Software Structure",
    "text": "Software Structure\nMost of the functions in this package provide 2 kind of API, the array-based API and the file-based API. The inputs and output of array-based functions generally are numpy or cupy arrays (Simply, cupy is a package that provides same functions as numpy but runs on GPU), while inputs and outputs of file-based functions are string of path to the array stored in disk. InSAR techniques that can be greatly accelerated with parallel processing are implented in cupy for better performance while all other functions are implented with numpy arrays. The file-based functions are not simple wrapper of the array-based functions. Due to the limitation of numpy and cupy, most array-based functions can only be runned on a single CPU core or on a single GPU. However, the file-based functions support parallel processing on multi-CPU-cores and multi-GPUs with the help of dask. But their is performance cost for using dask, sometimes the array-based functions is faster. Another benefit of dask is the memory usage is smaller as the processing on each chunks can be in sequence.\nAll functions in the file-based API starts with a prefix de to make them more distinguishable. Terminal commands of same name as the file-based functions is also provided. To make it simpler, we call the file-based functions and commands CLI (command line interface), the array-based API API. The API and CLI functions are arranged in different namespace. In this documentation website, if document of one API function xxx is in section API and subsection pl, then it is in the namespace decorrelation.pl, the correct way to import it is from decorrelation.pl import xxx. For CLI funtion de_xxx, it the document page is in section CLI and subsection pl, then it is in the namespace decorrelation.cli.pl and the correct way to import it is from decorrelation.cli.pl import de_xxx."
  },
  {
    "objectID": "Introduction/software_architecture.html#data-format",
    "href": "Introduction/software_architecture.html#data-format",
    "title": "Software Architecture",
    "section": "Data format",
    "text": "Data format\nMost of the stored data in this package is in the zarr format, which is a file storage format for chunked, compressed, N-dimensional arrays. The figure below shows how the structure of zarr data. The reading and writing speed is fast since the data volume is compressed. Before compressing, the data are divided into chunks to be more flexiable for dask parallel operation. Generally, the file name is xxxxxx.zarr. You will find it is indeed a directory in the file system. But just treat it as a single file in use.\n\n\n\nimga\n\n\nNote that the sturcture of dask array is similar. Each chunk of a big dask array is just a numpy or cupy array. Independent operations on every chunks are automatically parallelized.\nIn this software, there are mainly two kind of dataset. One is stack of raster data, another is stack of point cloud data. The raster dataset are divided into chunks along azimuth dimension, not range dimension. The point cloud dataset are divided into chunks along the spatial dimension. These two chunksize needs to be determined by the user. The chunksize in high dims are automatically determined. Users don’t need to care about it. Unproper chunksize slows down the processing speed or even crash the program. The rule of thumb is to maximize it while processing of one chunk fits the memory of one GPU."
  },
  {
    "objectID": "Introduction/software_architecture.html#an-example",
    "href": "Introduction/software_architecture.html#an-example",
    "title": "Software Architecture",
    "section": "An example",
    "text": "An example\nHere we provide an simple example. The API function decorrelation.pl.emi implemented the EMI phase linking method and decorrelation.cli.de_emi is the file-based API of it.\nImport them first:\n\nfrom decorrelation.pl import emi\nfrom decorrelation.cli.pl import de_emi\nfrom nbdev.showdoc import show_doc # this is just a function to show the document\n\n\nsource\n\nemi\n\n emi (coh:cupy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\n\nsource\n\n\nde_emi\n\n de_emi (coh:str, ph:str, emi_quality:str, ref:int=0,\n         point_chunk_size:int=None, log:str=None,\n         plot_emi_quality:bool=False, vmin:int=1.0, vmax:int=1.3,\n         ds_idx:str=None, shape:tuple=None, emi_quality_fig:str=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nstr\n\ncoherence matrix\n\n\nph\nstr\n\noutput, wrapped phase\n\n\nemi_quality\nstr\n\noutput, pixel quality\n\n\nref\nint\n0\nreference image for phase\n\n\npoint_chunk_size\nint\nNone\nparallel processing point chunk size\n\n\nlog\nstr\nNone\nlog\n\n\nplot_emi_quality\nbool\nFalse\nif plot the emi quality\n\n\nvmin\nint\n1.0\nmin value of emi quality to plot\n\n\nvmax\nint\n1.3\nmax value of emi quality to plot\n\n\nds_idx\nstr\nNone\nindex of ds\n\n\nshape\ntuple\nNone\nshape of one image\n\n\nemi_quality_fig\nstr\nNone\npath to save the emi quality plot, optional. Default, no saving\n\n\n\nTo apply the emi API funtion:\n\nimport zarr\nimport numpy as np\nimport cupy as cp\n\n\ncoh_zarr = zarr.open('./software_architecture/ds_can_coh.zarr/','r')\n\n\ncoh_zarr,coh_zarr.shape,coh_zarr.chunks,coh_zarr.dtype\n\n(&lt;zarr.core.Array (740397, 17, 17) complex64 read-only&gt;,\n (740397, 17, 17),\n (200000, 17, 17),\n dtype('complex64'))\n\n\nIt is coherence matrix for 740397 selected DS candidate and there are 17 SAR images. So the coherence matrix for one pixel is 17 \\(\\times\\) 17. The coherence matrix is stored in 4 chunks and each chunks stores data for 200000 DS candidate. (The last chunk only have 140397 DS candidate).\n\n!ls -al ./software_architecture/ds_can_coh.zarr/ #It is a directory indeed!\n\ntotal 1570400\ndrwxrwxr-x 2 kangl kangl      4096 Sep 28 12:30 .\ndrwxrwxr-x 5 kangl kangl      4096 Oct  4 12:15 ..\n-rw-rw-r-- 1 kangl kangl 434775676 Sep 28 12:30 0.0.0\n-rw-rw-r-- 1 kangl kangl 432578417 Sep 28 12:30 1.0.0\n-rw-rw-r-- 1 kangl kangl 434846911 Sep 28 12:30 2.0.0\n-rw-rw-r-- 1 kangl kangl 305857416 Sep 28 12:30 3.0.0\n-rw-rw-r-- 1 kangl kangl       398 Sep 28 12:30 .zarray\n\n\n\ncoh = coh_zarr[:] # read as numpy array\n\n\ncoh = cp.asarray(coh) # convert to cupy array\n\n\ncoh.shape\n\n(740397, 17, 17)\n\n\n\n# The processing is really fast!\nph,emi_quality = emi(coh)\n\nCPU times: user 1.18 s, sys: 447 ms, total: 1.62 s\nWall time: 1.69 s\n\n\nNow we apply the CLI function:\n\nde_emi('./software_architecture/ds_can_coh.zarr/',\n       './software_architecture/ds_can_ph.zarr',\n       './software_architecture/ds_can_emi_quality.zarr',\n       point_chunk_size = 200000)\n\n2023-10-08 23:30:17 - de_emi - INFO - fetching args:\n2023-10-08 23:30:17 - de_emi - INFO - coh = './software_architecture/ds_can_coh.zarr/'\n2023-10-08 23:30:17 - de_emi - INFO - ph = './software_architecture/ds_can_ph.zarr'\n2023-10-08 23:30:17 - de_emi - INFO - emi_quality = './software_architecture/ds_can_emi_quality.zarr'\n2023-10-08 23:30:17 - de_emi - INFO - ref = 0\n2023-10-08 23:30:17 - de_emi - INFO - point_chunk_size = 200000\n2023-10-08 23:30:17 - de_emi - INFO - log = None\n2023-10-08 23:30:17 - de_emi - INFO - plot_emi_quality = False\n2023-10-08 23:30:17 - de_emi - INFO - vmin = 1.0\n2023-10-08 23:30:17 - de_emi - INFO - vmax = 1.3\n2023-10-08 23:30:17 - de_emi - INFO - ds_idx = None\n2023-10-08 23:30:17 - de_emi - INFO - shape = None\n2023-10-08 23:30:17 - de_emi - INFO - emi_quality_fig = None\n2023-10-08 23:30:17 - de_emi - INFO - fetching args done.\n2023-10-08 23:30:17 - de_emi - INFO - coh dataset shape: (740397, 17, 17)\n2023-10-08 23:30:17 - de_emi - INFO - coh dataset chunks: (200000, 17, 17)\n2023-10-08 23:30:17 - de_emi - INFO - parallel processing point chunk size: 200000\n2023-10-08 23:30:17 - de_emi - INFO - starting dask CUDA local cluster.\n2023-10-08 23:30:23 - de_emi - INFO - dask local CUDA cluster started.\n2023-10-08 23:30:23 - de_emi - INFO - coh dask array shape: (740397, 17, 17)\n2023-10-08 23:30:23 - de_emi - INFO - coh dask array chunks: ((200000, 200000, 200000, 140397), (17,), (17,))\n2023-10-08 23:30:23 - de_emi - INFO - phase linking with EMI.\n2023-10-08 23:30:23 - de_emi - INFO - got ph and emi_quality.\n2023-10-08 23:30:23 - de_emi - INFO - ph dask array shape: (740397, 17)\n2023-10-08 23:30:23 - de_emi - INFO - ph dask array chunks: ((200000, 200000, 200000, 140397), (17,))\n2023-10-08 23:30:23 - de_emi - INFO - emi_quality dask array shape: (740397,)\n2023-10-08 23:30:23 - de_emi - INFO - emi_quality dask array chunks: ((200000, 200000, 200000, 140397),)\n2023-10-08 23:30:23 - de_emi - INFO - saving ph and emi_quality.\n2023-10-08 23:30:23 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-10-08 23:30:26 - de_emi - INFO - computing finished.\n2023-10-08 23:30:28 - de_emi - INFO - dask cluster closed.\nCPU times: user 637 ms, sys: 723 ms, total: 1.36 s\nWall time: 11.6 s\n\n\n2023-10-08 23:30:19,866 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,866 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,869 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,869 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,872 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,872 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,873 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,873 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,880 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,880 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,886 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,886 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,893 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,893 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-08 23:30:19,898 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-08 23:30:19,898 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\nThe CLI function is slower than the API function since it needs to read and write the data and set up the dask CUDA cluster.\nNotice that there is a point_chunk_size option in the CLI function, it means the data is processed in chunks seperately and each chunk have point_chunk_size pixels. By default, this number is set as the chunk size in the input zarr data.\nThere are more options in the CLI function, e.g., to save the printed information to the log file, to plot some result.\nAs mentioned, the CLI funtion also provide command line interface, but it won’t generate any plot on screen since it is not supported in terminal.\n\n!de_emi -h\n\nusage: de_emi [-h] [--ref REF] [--point_chunk_size POINT_CHUNK_SIZE] [--log LOG]\n              [--plot_emi_quality] [--vmin VMIN] [--vmax VMAX] [--ds_idx DS_IDX]\n              [--shape SHAPE] [--emi_quality_fig EMI_QUALITY_FIG]\n              coh ph emi_quality\n\npositional arguments:\n  coh                                  coherence matrix\n  ph                                   output, wrapped phase\n  emi_quality                          output, pixel quality\n\noptions:\n  -h, --help                           show this help message and exit\n  --ref REF                            reference image for phase (default: 0)\n  --point_chunk_size POINT_CHUNK_SIZE  parallel processing point chunk size\n  --log LOG                            log\n  --plot_emi_quality                   if plot the emi quality (default: False)\n  --vmin VMIN                          min value of emi quality to plot\n                                       (default: 1.0)\n  --vmax VMAX                          max value of emi quality to plot\n                                       (default: 1.3)\n  --ds_idx DS_IDX                      index of ds\n  --shape SHAPE                        shape of one image\n  --emi_quality_fig EMI_QUALITY_FIG    path to save the emi quality plot,\n                                       optional. Default, no saving\n\n\nThe CLI also include functions for simple data manipulation (e.g. array slicing and point clouds merging). As it is very easy to do them for numpy/cupy arrays, these CLI do not have corresponding API."
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html",
    "href": "Tutorials/adaptive_multilook.html",
    "title": "Adaptive Multilook",
    "section": "",
    "text": "In this tutorial, we demostrate how to use decorrelation package to identify spatially homogeneous pixels, extimate the coherence matrix and compare the original interferogram, multilook intergerogram and the adaptive multilook interferogram.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\n\nimport cupy as cp\nfrom cupyx.scipy.ndimage import uniform_filter\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.plot import bg_alpha\nfrom decorrelation.co import emperical_co"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "href": "Tutorials/adaptive_multilook.html#load-rslc-stack",
    "title": "Adaptive Multilook",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\ncp.cuda.Device(1).use()\n\n&lt;CUDA Device 1&gt;\n\n\n\nrslc = cp.asarray(zarr.open('../../data/rslc.zarr','r')[:])\nrslc.shape\n\n(2500, 1834, 17)"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "href": "Tutorials/adaptive_multilook.html#apply-ks-test",
    "title": "Adaptive Multilook",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nrmli = cp.abs(rslc)**2\n\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\np = ks_test(rmli,az_half_win=az_half_win,r_half_win=r_half_win)[1]\n\nCPU times: user 48.8 ms, sys: 10.5 ms, total: 59.3 ms\nWall time: 65 ms\n\n\nks_test in decorrelation package is extremely fast!"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#select-shps",
    "href": "Tutorials/adaptive_multilook.html#select-shps",
    "title": "Adaptive Multilook",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nshp_num_np = cp.asnumpy(shp_num)\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_np)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "href": "Tutorials/adaptive_multilook.html#estimate-coherence-matrix",
    "title": "Adaptive Multilook",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\n\ncoh = emperical_co(rslc,is_shp)[1]\n\nCPU times: user 259 ms, sys: 17.3 ms, total: 276 ms\nWall time: 285 ms"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#compare",
    "href": "Tutorials/adaptive_multilook.html#compare",
    "title": "Adaptive Multilook",
    "section": "Compare",
    "text": "Compare\nHere we compare 1-look interferogram, multilook interferogram and adaptive multilook interferogram\n\nref_image = 15\nsec_image = 16\n\n1 look interferogram:\n\ndiff = rslc[:,:,ref_image]*rslc[:,:,sec_image].conj()\n\nMultilook interferogram:\n\nml_diff = uniform_filter(diff,size=(az_win,r_win))\n\nAdaptive multilook interferogram:\n\nad_ml_diff = coh[:,:,ref_image,sec_image]\n\nThe plot background:\n\nplot_bg = rmli[:,:,0]\nplot_bg = cp.asnumpy(plot_bg)\nalpha = bg_alpha(plot_bg)\n\nPlot:\n\nfig,axes = plt.subplots(1,3,figsize=(24/2,7/2))\nxlabel = 'Range Index'\nylabel = 'Azimuth Index'\npcm0 = axes[0].imshow(cp.asnumpy(cp.angle(diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\npcm1 = axes[1].imshow(cp.asnumpy(cp.angle(ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\npcm2 = axes[2].imshow(cp.asnumpy(cp.angle(ad_ml_diff)),alpha=alpha,interpolation='nearest',cmap='hsv')\nfor ax in axes:\n    ax.set(facecolor = \"black\")\naxes[0].set(title='Orignal Interferogram',xlabel=xlabel,ylabel=ylabel)\naxes[1].set(title=f'Multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\naxes[2].set(title=f'Adaptively multilook {az_win} by {r_win}',xlabel=xlabel,ylabel=ylabel)\nfig.colorbar(pcm0,ax=axes[0])\nfig.colorbar(pcm1,ax=axes[1])\nfig.colorbar(pcm1,ax=axes[2])\nfig.show()"
  },
  {
    "objectID": "Tutorials/adaptive_multilook.html#conclusion",
    "href": "Tutorials/adaptive_multilook.html#conclusion",
    "title": "Adaptive Multilook",
    "section": "Conclusion",
    "text": "Conclusion\n\nAdaptive multilooking based on SHPs selection performs better than non-adaptive one;\nks_test and emperical_co implemented in decorrelation package are fast."
  },
  {
    "objectID": "Tutorials/ds_processing.html",
    "href": "Tutorials/ds_processing.html",
    "title": "DS Processing",
    "section": "",
    "text": "In this tutorial, we demostrate how to do standard DS processing with the decorrelation package.\nimport numpy as np\nimport zarr\nfrom matplotlib import pyplot as plt\nimport colorcet\n\nimport cupy as cp\nfrom cupyx.scipy.ndimage import uniform_filter\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.plot import bg_alpha\nfrom decorrelation.co import emperical_co_pc, isPD\nfrom decorrelation.pl import emi, temp_coh"
  },
  {
    "objectID": "Tutorials/ds_processing.html#load-rslc-stack",
    "href": "Tutorials/ds_processing.html#load-rslc-stack",
    "title": "DS Processing",
    "section": "Load rslc stack",
    "text": "Load rslc stack\n\nrslc = cp.asarray(zarr.open('../../data/rslc.zarr','r')[:])\nrslc.shape\n\n(2500, 1834, 17)"
  },
  {
    "objectID": "Tutorials/ds_processing.html#apply-ks-test",
    "href": "Tutorials/ds_processing.html#apply-ks-test",
    "title": "DS Processing",
    "section": "Apply ks test",
    "text": "Apply ks test\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\n\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\np = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)[1]"
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-shps",
    "href": "Tutorials/ds_processing.html#select-shps",
    "title": "DS Processing",
    "section": "Select SHPs",
    "text": "Select SHPs\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(shp_num),cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "Tutorials/ds_processing.html#select-dss",
    "href": "Tutorials/ds_processing.html#select-dss",
    "title": "DS Processing",
    "section": "Select DSs",
    "text": "Select DSs\nHere we select DSs candidate as pixels have more than 50 brothers.\n\nis_ds_can = shp_num &gt;= 50\n\nThe number of DSs:\n\ncp.count_nonzero(is_ds_can)\n\narray(740397)\n\n\nThe DSs distribution:\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(is_ds_can),cmap=colorcet.cm.fire)\nax.set(title='DS Candidate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "href": "Tutorials/ds_processing.html#estimate-coherence-matrix",
    "title": "DS Processing",
    "section": "Estimate coherence matrix",
    "text": "Estimate coherence matrix\nIn order to save memory, here we only estimate coherence matrix on selected DSs:\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.stack(cp.where(is_ds_can))\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n\nPlot the average coherence matrix:\n\nds_can_ave_coh = abs(ds_can_coh).mean(axis=0)\n\n\nds_can_ave_coh.shape\n\n(17, 17)\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(cp.asnumpy(ds_can_ave_coh),cmap=colorcet.cm.fire)\nax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\nThe coherence between the 5-th SLC and other SLC are bad. We may consider removing this image."
  },
  {
    "objectID": "Tutorials/ds_processing.html#phase-linking",
    "href": "Tutorials/ds_processing.html#phase-linking",
    "title": "DS Processing",
    "section": "Phase linking",
    "text": "Phase linking\nHere we apply the EMI method:\n\nds_can_ph, ds_can_emi_quality = emi(ds_can_coh)\nds_can_ph.shape, ds_can_emi_quality.shape\n\n((740397, 17), (740397,))\n\n\n\nds_can_emi_quality_2d = cp.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\nds_can_emi_quality_2d[:] = cp.nan\nds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_emi_quality_2d),interpolation='nearest',vmin=1,vmax=1.3)\nax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\nds_can_temp_coh = temp_coh(ds_can_coh,ds_can_ph)\nds_can_temp_coh.shape\n\n(740397,)\n\n\n\nds_can_temp_coh_2d = cp.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = cp.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_temp_coh_2d),interpolation='nearest')\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "Tutorials/ds_processing.html#refine-ds-candidate",
    "href": "Tutorials/ds_processing.html#refine-ds-candidate",
    "title": "DS Processing",
    "section": "Refine DS candidate",
    "text": "Refine DS candidate\nHere we select DS candidate based on EMI quality factor and temporal coherence:\n\n_is_ds_can_refined = (ds_can_emi_quality&gt;=1.0) & (ds_can_emi_quality &lt;1.2) & (ds_can_temp_coh &gt; 0.7) & (ds_can_temp_coh &lt;= 1.0)\n\n\nds_can_refined_idx = tuple(idx[_is_ds_can_refined] for idx in ds_can_idx)\nis_ds_can_refined = cp.zeros_like(is_ds_can)\nis_ds_can_refined[ds_can_refined_idx] = True\n\n\nds_can_refined_coh = ds_can_coh[_is_ds_can_refined]\nds_can_refined_ph = ds_can_ph[_is_ds_can_refined]\n\n\nds_can_refined_coh.shape\n\n(460076, 17, 17)\n\n\nPlot the average coherence matrix and refined DS candiate distribution:\n\nds_can_refined_ave_coh = abs(ds_can_refined_coh).mean(axis=0)\nfig, ax = plt.subplots(1,1,figsize=(15,10))\npcm = ax.imshow(cp.asnumpy(ds_can_refined_ave_coh),cmap=colorcet.cm.fire)\nax.set(title='Average Coherence Matrix',xlabel='Image Index',ylabel='Image Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(is_ds_can_refined),cmap=colorcet.cm.fire)\nax.set(title='DS Candidate Refined distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\nWe find the coherence matrix gets better and noisy pixels are moved."
  },
  {
    "objectID": "Tutorials/ds_processing_with_cli.html",
    "href": "Tutorials/ds_processing_with_cli.html",
    "title": "DS processing with CLI",
    "section": "",
    "text": "In this tutorial, we demostrate how to do standard DS processing with the decorrelation CLI interface."
  },
  {
    "objectID": "Tutorials/ds_processing_with_cli.html#load-gamma-result",
    "href": "Tutorials/ds_processing_with_cli.html#load-gamma-result",
    "title": "DS processing with CLI",
    "section": "Load GAMMA result",
    "text": "Load GAMMA result\nThe data from gamma software needed for this tutorial:\n\n!ls -R ../../data/gamma/\n\n../../data/gamma/:\nDEM  geocoding  rslc\n\n../../data/gamma/DEM:\ndem_seg  dem_seg_par\n\n../../data/gamma/geocoding:\n20210802.diff_par  20210802.lt_fine  20210802.lv_theta\n20210802.hgt       20210802.lv_phi\n\n../../data/gamma/rslc:\n20210802.rslc      20211011.rslc.par  20220718.rslc  20220912.rslc.par\n20210802.rslc.par  20211025.rslc      20220718.rslc.par  20220926.rslc\n20210816.rslc      20211025.rslc.par  20220801.rslc  20220926.rslc.par\n20210816.rslc.par  20220606.rslc      20220801.rslc.par  20221010.rslc\n20210830.rslc      20220606.rslc.par  20220815.rslc  20221010.rslc.par\n20210830.rslc.par  20220620.rslc      20220815.rslc.par  20221024.rslc\n20210913.rslc      20220620.rslc.par  20220829.rslc  20221024.rslc.par\n20210913.rslc.par  20220704.rslc      20220829.rslc.par\n20211011.rslc      20220704.rslc.par  20220912.rslc\n\n\nAnd we load them with functions in the load module:\n\nfrom decorrelation.cli.load import (de_load_gamma_flatten_rslc,\n                                    de_load_gamma_lat_lon_hgt,\n                                    de_load_gamma_look_vector,\n                                    de_load_gamma_range,\n                                    de_load_gamma_metadata)\n\nThe detailed usage of these functions is explained here\n\nrslc_dir = '../../data/gamma/rslc'\nreference = '20220620'\nrslc_par = '../../data/gamma/rslc/20220620.rslc.par'\nhgt = '../../data/gamma/geocoding/20210802.hgt'\nlt = '../../data/gamma/geocoding/20210802.lt_fine'\ndiff_par = '../../data/gamma/geocoding/20210802.diff_par'\ndem_par = '../../data/gamma/DEM/dem_seg_par'\ntheta = '../../data/gamma/geocoding/20210802.lv_theta'\nphi = '../../data/gamma/geocoding/20210802.lv_phi'\naz_chunk_size = 1000\n\nrslc_zarr = './DS_Processing_with_CLI/rslc.zarr'\nlat_zarr = './DS_Processing_with_CLI/lat.zarr'\nlon_zarr = './DS_Processing_with_CLI/lon.zarr'\ntheta_zarr = './DS_Processing_with_CLI/theta.zarr'\nphi_zarr = './DS_Processing_with_CLI/phi.zarr'\nhgt_zarr = './DS_Processing_with_CLI/hgt.zarr'\nrange_zarr = './DS_Processing_with_CLI/range.zarr'\nmeta_file = './DS_Processing_with_CLI/meta.toml'\n\n\nde_load_gamma_flatten_rslc(rslc_dir,reference,hgt,rslc_zarr,az_chunk_size)\nde_load_gamma_lat_lon_hgt(diff_par,rslc_par,dem_par,hgt,lat_zarr,lon_zarr,hgt_zarr,az_chunk_size)\nde_load_gamma_look_vector(theta,phi,lt,rslc_par,dem_par,theta_zarr,phi_zarr,az_chunk_size)\nde_load_gamma_range(rslc_par,range_zarr,az_chunk_size)\nde_load_gamma_metadata(rslc_dir,reference,meta_file)\n\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - fetching args:\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - reference = '20220620'\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - rslc_zarr = './DS_Processing_with_CLI/rslc.zarr'\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - az_chunk_size = 1000\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - log = None\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - fetching args done.\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - rslc found: \n        date                                 rslc  \\\n0   20210802  ../../data/gamma/rslc/20210802.rslc   \n1   20210816  ../../data/gamma/rslc/20210816.rslc   \n2   20210830  ../../data/gamma/rslc/20210830.rslc   \n3   20210913  ../../data/gamma/rslc/20210913.rslc   \n4   20211011  ../../data/gamma/rslc/20211011.rslc   \n5   20211025  ../../data/gamma/rslc/20211025.rslc   \n6   20220606  ../../data/gamma/rslc/20220606.rslc   \n7   20220620  ../../data/gamma/rslc/20220620.rslc   \n8   20220704  ../../data/gamma/rslc/20220704.rslc   \n9   20220718  ../../data/gamma/rslc/20220718.rslc   \n10  20220801  ../../data/gamma/rslc/20220801.rslc   \n11  20220815  ../../data/gamma/rslc/20220815.rslc   \n12  20220829  ../../data/gamma/rslc/20220829.rslc   \n13  20220912  ../../data/gamma/rslc/20220912.rslc   \n14  20220926  ../../data/gamma/rslc/20220926.rslc   \n15  20221010  ../../data/gamma/rslc/20221010.rslc   \n16  20221024  ../../data/gamma/rslc/20221024.rslc   \n\n                                        par  \n0   ../../data/gamma/rslc/20210802.rslc.par  \n1   ../../data/gamma/rslc/20210816.rslc.par  \n2   ../../data/gamma/rslc/20210830.rslc.par  \n3   ../../data/gamma/rslc/20210913.rslc.par  \n4   ../../data/gamma/rslc/20211011.rslc.par  \n5   ../../data/gamma/rslc/20211025.rslc.par  \n6   ../../data/gamma/rslc/20220606.rslc.par  \n7   ../../data/gamma/rslc/20220620.rslc.par  \n8   ../../data/gamma/rslc/20220704.rslc.par  \n9   ../../data/gamma/rslc/20220718.rslc.par  \n10  ../../data/gamma/rslc/20220801.rslc.par  \n11  ../../data/gamma/rslc/20220815.rslc.par  \n12  ../../data/gamma/rslc/20220829.rslc.par  \n13  ../../data/gamma/rslc/20220912.rslc.par  \n14  ../../data/gamma/rslc/20220926.rslc.par  \n15  ../../data/gamma/rslc/20221010.rslc.par  \n16  ../../data/gamma/rslc/20221024.rslc.par  \n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - number of images: 17.\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - image number of lines: 2500.\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - image width: 1834.\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - run gamma command to generate required data for flattened rslcs:\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par /tmp/tmp_vdp1egt/20220620_20210802.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:18 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210802.rslc.par /tmp/tmp_vdp1egt/20220620_20210802.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20210802.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:23 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par /tmp/tmp_vdp1egt/20220620_20210816.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:23 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210816.rslc.par /tmp/tmp_vdp1egt/20220620_20210816.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20210816.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:24 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par /tmp/tmp_vdp1egt/20220620_20210830.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:24 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210830.rslc.par /tmp/tmp_vdp1egt/20220620_20210830.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20210830.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:26 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par /tmp/tmp_vdp1egt/20220620_20210913.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:26 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20210913.rslc.par /tmp/tmp_vdp1egt/20220620_20210913.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20210913.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:29 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par /tmp/tmp_vdp1egt/20220620_20211011.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:29 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211011.rslc.par /tmp/tmp_vdp1egt/20220620_20211011.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20211011.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:30 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par /tmp/tmp_vdp1egt/20220620_20211025.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:30 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20211025.rslc.par /tmp/tmp_vdp1egt/20220620_20211025.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20211025.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:31 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par /tmp/tmp_vdp1egt/20220620_20220606.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:31 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220606.rslc.par /tmp/tmp_vdp1egt/20220620_20220606.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220606.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:33 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par /tmp/tmp_vdp1egt/20220620_20220620.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:33 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220620.rslc.par /tmp/tmp_vdp1egt/20220620_20220620.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220620.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:34 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par /tmp/tmp_vdp1egt/20220620_20220704.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:34 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220704.rslc.par /tmp/tmp_vdp1egt/20220620_20220704.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220704.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:35 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par /tmp/tmp_vdp1egt/20220620_20220718.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:35 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220718.rslc.par /tmp/tmp_vdp1egt/20220620_20220718.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220718.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:36 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par /tmp/tmp_vdp1egt/20220620_20220801.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:36 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220801.rslc.par /tmp/tmp_vdp1egt/20220620_20220801.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220801.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:37 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par /tmp/tmp_vdp1egt/20220620_20220815.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:37 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220815.rslc.par /tmp/tmp_vdp1egt/20220620_20220815.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220815.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:39 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par /tmp/tmp_vdp1egt/20220620_20220829.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:39 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220829.rslc.par /tmp/tmp_vdp1egt/20220620_20220829.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220829.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:41 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par /tmp/tmp_vdp1egt/20220620_20220912.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:41 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220912.rslc.par /tmp/tmp_vdp1egt/20220620_20220912.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220912.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:43 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par /tmp/tmp_vdp1egt/20220620_20220926.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:43 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20220926.rslc.par /tmp/tmp_vdp1egt/20220620_20220926.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20220926.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:44 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par /tmp/tmp_vdp1egt/20220620_20221010.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:44 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221010.rslc.par /tmp/tmp_vdp1egt/20220620_20221010.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20221010.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:45 - de_load_gamma_flatten_rslc - INFO - run command: create_offset ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par /tmp/tmp_vdp1egt/20220620_20221024.off 1 1 1 0 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:45 - de_load_gamma_flatten_rslc - INFO - run command: phase_sim_orb ../../data/gamma/rslc/20220620.rslc.par ../../data/gamma/rslc/20221024.rslc.par /tmp/tmp_vdp1egt/20220620_20221024.off ../../data/gamma/geocoding/20210802.hgt /tmp/tmp_vdp1egt/20220620_20221024.sim_orb ../../data/gamma/rslc/20220620.rslc.par - - 1 1 &gt; /tmp/tmp_vdp1egt/log\n2023-10-13 21:40:47 - de_load_gamma_flatten_rslc - INFO - gamma command finished.\n2023-10-13 21:40:47 - de_load_gamma_flatten_rslc - INFO - using dask to load data in gamma binary format to calculate flatten rslcs and save it to zarr.\n2023-10-13 21:40:47 - de_load_gamma_flatten_rslc - INFO - starting dask local cluster.\n2023-10-13 21:40:49 - de_load_gamma_flatten_rslc - INFO - dask local cluster started.\n2023-10-13 21:40:49 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array shape: (2500, 1834, 17)\n2023-10-13 21:40:49 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array chunksize: (1000, 1834, 1)\n2023-10-13 21:40:49 - de_load_gamma_flatten_rslc - INFO - flattened rslc dask array dtype: complex64\n2023-10-13 21:40:49 - de_load_gamma_flatten_rslc - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:40:50 - de_load_gamma_flatten_rslc - INFO - computing finished.\n2023-10-13 21:40:51 - de_load_gamma_flatten_rslc - INFO - dask cluster closed.\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - fetching args:\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - diff_par = '../../data/gamma/geocoding/20210802.diff_par'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - hgt = '../../data/gamma/geocoding/20210802.hgt'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - lat_zarr = './DS_Processing_with_CLI/lat.zarr'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - lon_zarr = './DS_Processing_with_CLI/lon.zarr'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - hgt_zarr = './DS_Processing_with_CLI/hgt.zarr'\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - az_chunk_size = 1000\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - log = None\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - fetching args done.\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - image shape: (2500,1834)\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - run gamma command to generate longitude, latitude and height:\n2023-10-13 21:40:51 - de_load_gamma_lat_lon_hgt - INFO - run command: pt2geo /tmp/tmpr41c952x/plist - ../../data/gamma/rslc/20220620.rslc.par - ../../data/gamma/geocoding/20210802.hgt ../../data/gamma/DEM/dem_seg_par ../../data/gamma/geocoding/20210802.diff_par 1 1 - - /tmp/tmpr41c952x/plat_lon /tmp/tmpr41c952x/phgt_wgs84 &gt; /tmp/tmpr41c952x/log\n2023-10-13 21:41:04 - de_load_gamma_lat_lon_hgt - INFO - gamma command finished.\n2023-10-13 21:41:04 - de_load_gamma_lat_lon_hgt - INFO - Done.\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - fetching args:\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - theta = '../../data/gamma/geocoding/20210802.lv_theta'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - phi = '../../data/gamma/geocoding/20210802.lv_phi'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - lt = '../../data/gamma/geocoding/20210802.lt_fine'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - dem_par = '../../data/gamma/DEM/dem_seg_par'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - theta_zarr = './DS_Processing_with_CLI/theta.zarr'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - phi_zarr = './DS_Processing_with_CLI/phi.zarr'\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - az_chunk_size = 1000\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - log = None\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - fetching args done.\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - image shape: (2500,1834)\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - run gamma command to generate elevation angle in range doppler coordinate:\n2023-10-13 21:41:04 - de_load_gamma_look_vector - INFO - run command: geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_theta 5741 /tmp/tmpb03khaiu/theta_rdc 1834 2500 &gt; /tmp/tmpb03khaiu/log\n2023-10-13 21:41:06 - de_load_gamma_look_vector - INFO - gamma command finished.\n2023-10-13 21:41:06 - de_load_gamma_look_vector - INFO - writing data.\n2023-10-13 21:41:06 - de_load_gamma_look_vector - INFO - run gamma command to generate orientation angle in range doppler coordinate:\n2023-10-13 21:41:06 - de_load_gamma_look_vector - INFO - run command: geocode ../../data/gamma/geocoding/20210802.lt_fine ../../data/gamma/geocoding/20210802.lv_phi 5741 /tmp/tmpb03khaiu/phi_rdc 1834 2500 &gt; /tmp/tmpb03khaiu/log\n2023-10-13 21:41:07 - de_load_gamma_look_vector - INFO - gamma command finished.\n2023-10-13 21:41:07 - de_load_gamma_look_vector - INFO - writing data.\n2023-10-13 21:41:07 - de_load_gamma_look_vector - INFO - Done.\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - fetching args:\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - rslc_par = '../../data/gamma/rslc/20220620.rslc.par'\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - range_zarr = './DS_Processing_with_CLI/range.zarr'\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - az_chunk_size = 1000\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - log = None\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - fetching args done.\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - image shape: (2500,1834)\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - Calculating slant range distance.\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - writing data.\n2023-10-13 21:41:07 - de_load_gamma_range - INFO - Done.\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - fetching args:\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - rslc_dir = '../../data/gamma/rslc'\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - reference = '20220620'\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - meta_file = './DS_Processing_with_CLI/meta.toml'\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - log = None\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - fetching args done.\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - Fetching heading angle\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - Fetching range pixel spacing\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - fetching azimuth pixel spacing\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - Fetching randar wavelength\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - Run gamma command to calculate baseline:\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - run command: base_calc /tmp/tmpvt001mob/slc_tab ../../data/gamma/rslc/20220620.rslc.par /tmp/tmpvt001mob/bperp /tmp/tmpvt001mob/itab - &gt; /tmp/tmpvt001mob/log\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - gamma command finished.\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - All meta data: \ndates = [ \"20210802\", \"20210816\", \"20210830\", \"20210913\", \"20211011\", \"20211025\", \"20220606\", \"20220620\", \"20220704\", \"20220718\", \"20220801\", \"20220815\", \"20220829\", \"20220912\", \"20220926\", \"20221010\", \"20221024\",]\nradar_wavelength = 0.24245249210715603\nrange_pixel_spacing = 4.29054\nazimuth_pixel_spacing = 3.740105\nperpendicular_baseline = [ -97.61360168457031, -45.58580017089844, 17.86680030822754, -26.258899688720703, -63.72420120239258, -56.363399505615234, 64.75759887695312, 0.0, -9.043999671936035, -13.02869987487793, -112.94960021972656, -86.09490203857422, -129.9635009765625, -127.6594009399414, -182.29519653320312, -129.735107421875, -184.31100463867188,]\n\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - writing data in toml file.\n2023-10-13 21:41:07 - de_load_gamma_metadata - INFO - Done.\n\n\nThen we get all needed data: look vector, latitude, lontitude, height, metadata, slant range distance, and flattened rslc stack."
  },
  {
    "objectID": "Tutorials/ds_processing_with_cli.html#ds-candidates-selection",
    "href": "Tutorials/ds_processing_with_cli.html#ds-candidates-selection",
    "title": "DS processing with CLI",
    "section": "DS candidates selection",
    "text": "DS candidates selection\nFirst, we select spatial homogenious pixels:\n\nfrom decorrelation.cli.shp import de_shp_test\n\n\nrslc = './DS_Processing_with_CLI/rslc.zarr'\npvalue = './DS_Processing_with_CLI/pvalue.zarr'\naz_half_win = 5\nr_half_win = 5\nmethod = 'ks'\naz_chunk_size = 1000\n\n\nde_shp_test(rslc,pvalue,\n            az_half_win=az_half_win,r_half_win=r_half_win,\n            method=method,az_chunk_size=az_chunk_size)\n\n2023-10-13 21:42:46 - de_shp_test - INFO - fetching args:\n2023-10-13 21:42:46 - de_shp_test - INFO - rslc = './DS_Processing_with_CLI/rslc.zarr'\n2023-10-13 21:42:46 - de_shp_test - INFO - pvalue = './DS_Processing_with_CLI/pvalue.zarr'\n2023-10-13 21:42:46 - de_shp_test - INFO - az_half_win = 5\n2023-10-13 21:42:46 - de_shp_test - INFO - r_half_win = 5\n2023-10-13 21:42:46 - de_shp_test - INFO - method = 'ks'\n2023-10-13 21:42:46 - de_shp_test - INFO - az_chunk_size = 1000\n2023-10-13 21:42:46 - de_shp_test - INFO - log = None\n2023-10-13 21:42:46 - de_shp_test - INFO - fetching args done.\n2023-10-13 21:42:46 - de_shp_test - INFO - hypothetic test method: ks\n2023-10-13 21:42:46 - de_shp_test - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-10-13 21:42:46 - de_shp_test - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray chunks: (1000, 1834, 1)\n2023-10-13 21:42:46 - de_shp_test - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray dtype: complex64\n2023-10-13 21:42:46 - de_shp_test - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 21:42:46 - de_shp_test - INFO - starting dask CUDA local cluster.\n2023-10-13 21:42:51 - de_shp_test - INFO - dask local CUDA cluster started.\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc dask array dtype: complex64\n2023-10-13 21:42:51 - de_shp_test - INFO - azimuth half window size: 5; azimuth window size: 11\n2023-10-13 21:42:51 - de_shp_test - INFO - range half window size: 5; range window size: 11\n2023-10-13 21:42:51 - de_shp_test - INFO - setting shared boundaries between rlsc chunks.\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc with overlap dask array shape: (2520, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc with overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rslc with overlap dask array dtype: complex64\n2023-10-13 21:42:51 - de_shp_test - INFO - rmli with overlap dask array shape: (2520, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rmli with overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 21:42:51 - de_shp_test - INFO - rmli with overlap dask array dtype: float32\n2023-10-13 21:42:51 - de_shp_test - INFO - applying test on sorted rmli stack.\n2023-10-13 21:42:51 - de_shp_test - INFO - p value generated\n2023-10-13 21:42:51 - de_shp_test - INFO - p value dask array shape: (2520, 1834, 11, 11)\n2023-10-13 21:42:51 - de_shp_test - INFO - p value dask array chunksize: (1010, 1834, 11, 11)\n2023-10-13 21:42:51 - de_shp_test - INFO - p value dask array dtype: float32\n2023-10-13 21:42:51 - de_shp_test - INFO - trim shared boundaries between p value chunks\n2023-10-13 21:42:51 - de_shp_test - INFO - trimmed p value dask array shape: (2500, 1834, 11, 11)\n2023-10-13 21:42:51 - de_shp_test - INFO - trimmed p value dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 21:42:51 - de_shp_test - INFO - trimmed p value dask array dtype: float32\n2023-10-13 21:42:52 - de_shp_test - INFO - saving p value.\n2023-10-13 21:42:52 - de_shp_test - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:42:57 - de_shp_test - INFO - computing finished.\n2023-10-13 21:42:58 - de_shp_test - INFO - dask cluster closed.\n\n\n2023-10-13 21:42:48,068 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,068 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,068 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,068 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,086 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,087 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,087 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,087 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,087 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,087 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,088 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,088 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,089 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,089 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:48,089 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:48,089 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\nHere we use two sample Kolmogorov-Smirnov (KS) test for SHP identification. The output pvalue is the P-value for this test. The smaller the p-value, the more likely the two sample are from same distribution, i.e., the more likely the two pixels are SHP to each other.\nThen we select SHP by setting a threshold on this Pvalue, and select DS by seeting a threshold on the number of SHP pixels have. They are done with one single function:\n\nfrom decorrelation.cli.shp import de_select_ds_can\n\n\nds_can_is_shp = './DS_Processing_with_CLI/ds_can_is_shp.zarr'\nds_can_idx = './DS_Processing_with_CLI/ds_can_idx.zarr'\nshp_num_fig = './DS_Processing_with_CLI/shp_num_fig.png'\nis_ds_can_fig = './DS_Processing_with_CLI/is_ds_can.png'\naz_chunk_size = 1000\np_max = 0.05\nshp_num_min=50\nds_can_chunk_size = 100000\n\n\nde_select_ds_can(pvalue,ds_can_idx,ds_can_is_shp,\n                 p_max=p_max,az_chunk_size=az_chunk_size,\n                 shp_num_fig=shp_num_fig,is_ds_can_fig=is_ds_can_fig)\n\n2023-10-13 21:41:21 - de_select_ds_can - INFO - fetching args:\n2023-10-13 21:41:21 - de_select_ds_can - INFO - pvalue = './DS_Processing_with_CLI/pvalue.zarr'\n2023-10-13 21:41:21 - de_select_ds_can - INFO - ds_can_idx = './DS_Processing_with_CLI/ds_can_idx.zarr'\n2023-10-13 21:41:21 - de_select_ds_can - INFO - ds_can_is_shp = './DS_Processing_with_CLI/ds_can_is_shp.zarr'\n2023-10-13 21:41:21 - de_select_ds_can - INFO - p_max = 0.05\n2023-10-13 21:41:21 - de_select_ds_can - INFO - shp_num_min = 50\n2023-10-13 21:41:21 - de_select_ds_can - INFO - az_chunk_size = 1000\n2023-10-13 21:41:21 - de_select_ds_can - INFO - n_pc_chunk = None\n2023-10-13 21:41:21 - de_select_ds_can - INFO - pc_chunk_size = None\n2023-10-13 21:41:21 - de_select_ds_can - INFO - shp_num_fig = './DS_Processing_with_CLI/shp_num_fig.png'\n2023-10-13 21:41:21 - de_select_ds_can - INFO - is_ds_can_fig = './DS_Processing_with_CLI/is_ds_can.png'\n2023-10-13 21:41:21 - de_select_ds_can - INFO - log = None\n2023-10-13 21:41:21 - de_select_ds_can - INFO - fetching args done.\n2023-10-13 21:41:21 - de_select_ds_can - INFO - ./DS_Processing_with_CLI/pvalue.zarr zarray shape: (2500, 1834, 11, 11)\n2023-10-13 21:41:21 - de_select_ds_can - INFO - ./DS_Processing_with_CLI/pvalue.zarr zarray chunks: (1000, 1834, 11, 11)\n2023-10-13 21:41:21 - de_select_ds_can - INFO - ./DS_Processing_with_CLI/pvalue.zarr zarray dtype: float32\n2023-10-13 21:41:21 - de_select_ds_can - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 21:41:21 - de_select_ds_can - INFO - starting dask local cluster.\n2023-10-13 21:41:23 - de_select_ds_can - INFO - dask local cluster started.\n2023-10-13 21:41:23 - de_select_ds_can - INFO - pvalue dask array shape: (2500, 1834, 11, 11)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - pvalue dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - pvalue dask array dtype: float32\n2023-10-13 21:41:23 - de_select_ds_can - INFO - selecting SHPs based on pvalue threshold: 0.05\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_shp dask array shape: (2500, 1834, 11, 11)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_shp dask array chunksize: (1000, 1834, 11, 11)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_shp dask array dtype: bool\n2023-10-13 21:41:23 - de_select_ds_can - INFO - selecting DS candidates based on minimum of number of SHPs: 50\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_ds_can dask array shape: (2500, 1834)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_ds_can dask array chunksize: (1000, 1834)\n2023-10-13 21:41:23 - de_select_ds_can - INFO - is_ds_can dask array dtype: bool\n2023-10-13 21:41:23 - de_select_ds_can - INFO - calculate ds_can index:\n2023-10-13 21:41:23 - de_select_ds_can - INFO - slice is_shp on ds_can index:\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array shape: (2, 740397)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array chunksize: (1, 346329)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array dtype: int64\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array chunksize: (346329, 11, 11)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 21:41:27 - de_select_ds_can - INFO - set pc_chunk_size as az_chunk_size: 1000\n2023-10-13 21:41:27 - de_select_ds_can - INFO - rechunk ds_can_idx and ds_can_is_shp:\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array shape: (2, 740397)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array chunksize: (2, 1000)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_idx dask array dtype: int64\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array chunksize: (1000, 11, 11)\n2023-10-13 21:41:27 - de_select_ds_can - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 21:41:28 - de_select_ds_can - INFO - saving ds_can_is_shp.\n2023-10-13 21:41:28 - de_select_ds_can - INFO - saving ds_can_idx.\n2023-10-13 21:41:28 - de_select_ds_can - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:41:34 - de_select_ds_can - INFO - computing finished.\n2023-10-13 21:41:34 - de_select_ds_can - INFO - dask cluster closed.\n2023-10-13 21:41:34 - de_select_ds_can - INFO - plotting number of SHPs.\n2023-10-13 21:41:35 - de_select_ds_can - INFO - plotting DS candidate distribution.\n\n\n\n\n\n\n\n\nThe output ds_can_is_shp indicate wheather a DS candidate in the window is a SHP to its center pixel. ds_can_idx is a int array with shape of (2, num_of_DS_can). It indicate the position of DS candidate in radar coordinate."
  },
  {
    "objectID": "Tutorials/ds_processing_with_cli.html#coherence-matrix-estimation",
    "href": "Tutorials/ds_processing_with_cli.html#coherence-matrix-estimation",
    "title": "DS processing with CLI",
    "section": "Coherence matrix estimation",
    "text": "Coherence matrix estimation\nThen we estimate the coherence matrix of ds candidate:\n\nfrom decorrelation.cli.co import de_emperical_co_pc\n\n\nds_can_coh = './DS_Processing_with_CLI/ds_can_coh.zarr'\naz_chunk_size = 1000\nds_can_coh_ave_fig = './DS_Processing_with_CLI/ds_can_coh_ave.png'\n\n\nde_emperical_co_pc(rslc,ds_can_is_shp,ds_can_idx,ds_can_coh,\n                   az_chunk_size=az_chunk_size,\n                   ds_can_coh_ave_fig=ds_can_coh_ave_fig)\n\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - fetching args:\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - rslc = './DS_Processing_with_CLI/rslc.zarr'\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ds_can_is_shp = './DS_Processing_with_CLI/ds_can_is_shp.zarr'\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ds_can_idx = './DS_Processing_with_CLI/ds_can_idx.zarr'\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ds_can_coh = './DS_Processing_with_CLI/ds_can_coh.zarr'\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - az_chunk_size = 1000\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - n_pc_chunk = None\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - pc_chunk_size = None\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ds_can_coh_ave_fig = './DS_Processing_with_CLI/ds_can_coh_ave.png'\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - log = None\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - fetching args done.\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray shape: (2500, 1834, 17)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray chunks: (1000, 1834, 1)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/rslc.zarr zarray dtype: complex64\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_is_shp.zarr zarray shape: (740397, 11, 11)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_is_shp.zarr zarray chunks: (1000, 11, 11)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_is_shp.zarr zarray dtype: bool\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_idx.zarr zarray shape: (2, 740397)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_idx.zarr zarray chunks: (2, 1000)\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - ./DS_Processing_with_CLI/ds_can_idx.zarr zarray dtype: int64\n2023-10-13 21:41:36 - de_emperical_co_pc - INFO - loading ds_can_idx into memory.\n2023-10-13 21:41:37 - de_emperical_co_pc - INFO - got azimuth window size and half azimuth window size from is_shp shape: 11, 5\n2023-10-13 21:41:37 - de_emperical_co_pc - INFO - got range window size and half range window size from is_shp shape: 11, 5\n2023-10-13 21:41:37 - de_emperical_co_pc - INFO - parallel processing azimuth chunk size: 1000\n2023-10-13 21:41:37 - de_emperical_co_pc - INFO - starting dask CUDA local cluster.\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - dask local CUDA cluster started.\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - create raster bool array is_ds_can from ds_can_idx\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - create dask bool array is_ds_can\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can dask array shape: (2500, 1834)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can dask array chunksize: (1000, 1834)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can dask array dtype: bool\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - Using azimuth chunk size as the processing chunk size.\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - Calculate point chunk size\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - Point chunk size: (346329, 274921, 119147)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc dask array shape: (2500, 1834, 17)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc dask array chunksize: (1000, 1834, 17)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc dask array dtype: complex64\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - ds_can_is_shp dask array shape: (740397, 11, 11)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - ds_can_is_shp dask array chunksize: (346329, 11, 11)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - ds_can_is_shp dask array dtype: bool\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - setting shared boundaries between rlsc chunks.\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc_overlap dask array shape: (2520, 1834, 17)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc_overlap dask array chunksize: (1010, 1834, 17)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - rslc_overlap dask array dtype: complex64\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - padding zero between is_ds_can chunks.\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can_padded dask array shape: (2520, 1834)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can_padded dask array chunksize: (1010, 1834)\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - is_ds_can_padded dask array dtype: bool\n2023-10-13 21:41:42 - de_emperical_co_pc - INFO - estimating coherence matrix.\n2023-10-13 21:41:43 - de_emperical_co_pc - INFO - got coherence matrix.\n2023-10-13 21:41:43 - de_emperical_co_pc - INFO - set pc_chunk_size as az_chunk_size: 1000\n2023-10-13 21:41:43 - de_emperical_co_pc - INFO - rechunking ds_can_coh to chunk size (for saving with zarr): (1000, 17, 17)\n2023-10-13 21:41:43 - de_emperical_co_pc - INFO - saving ds_can_coh.\n2023-10-13 21:41:43 - de_emperical_co_pc - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:42:16 - de_emperical_co_pc - INFO - computing finished.\n2023-10-13 21:42:17 - de_emperical_co_pc - INFO - dask cluster closed.\n\n\n2023-10-13 21:41:39,186 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,186 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,186 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,186 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,189 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,199 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,199 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,202 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,202 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:41:39,205 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:41:39,205 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize"
  },
  {
    "objectID": "Tutorials/ds_processing_with_cli.html#phase-linking",
    "href": "Tutorials/ds_processing_with_cli.html#phase-linking",
    "title": "DS processing with CLI",
    "section": "Phase linking",
    "text": "Phase linking\nTo get rid of the closure phase, phase linking is applied here:\n\nfrom decorrelation.cli.pl import de_emi\nimport zarr\n\n\nds_can_ph = './DS_Processing_with_CLI/ds_can_ph.zarr'\nds_can_emi_quality = './DS_Processing_with_CLI/ds_can_emi_quality.zarr'\nref = 0\nvmin=1.0\nvmax=1.3\nemi_quality_fig = './DS_Processing_with_CLI/emi_quality.png'\n\n\nshape = zarr.open(pvalue,'r').shape[:2]\n\n\nde_emi(ds_can_coh,ds_can_ph,ds_can_emi_quality,\n       ref=ref,point_chunk_size=None,\n       plot_emi_quality=True,vmin=vmin,vmax=vmax,\n       ds_idx=ds_can_idx,shape=shape,emi_quality_fig=emi_quality_fig)\n\n2023-10-13 21:42:17 - de_emi - INFO - fetching args:\n2023-10-13 21:42:17 - de_emi - INFO - coh = './DS_Processing_with_CLI/ds_can_coh.zarr'\n2023-10-13 21:42:17 - de_emi - INFO - ph = './DS_Processing_with_CLI/ds_can_ph.zarr'\n2023-10-13 21:42:17 - de_emi - INFO - emi_quality = './DS_Processing_with_CLI/ds_can_emi_quality.zarr'\n2023-10-13 21:42:17 - de_emi - INFO - ref = 0\n2023-10-13 21:42:17 - de_emi - INFO - point_chunk_size = None\n2023-10-13 21:42:17 - de_emi - INFO - log = None\n2023-10-13 21:42:17 - de_emi - INFO - plot_emi_quality = True\n2023-10-13 21:42:17 - de_emi - INFO - vmin = 1.0\n2023-10-13 21:42:17 - de_emi - INFO - vmax = 1.3\n2023-10-13 21:42:17 - de_emi - INFO - ds_idx = './DS_Processing_with_CLI/ds_can_idx.zarr'\n2023-10-13 21:42:17 - de_emi - INFO - shape = (2500, 1834)\n2023-10-13 21:42:17 - de_emi - INFO - emi_quality_fig = './DS_Processing_with_CLI/emi_quality.png'\n2023-10-13 21:42:17 - de_emi - INFO - fetching args done.\n2023-10-13 21:42:17 - de_emi - INFO - ./DS_Processing_with_CLI/ds_can_coh.zarr zarray shape: (740397, 17, 17)\n2023-10-13 21:42:17 - de_emi - INFO - ./DS_Processing_with_CLI/ds_can_coh.zarr zarray chunks: (1000, 17, 17)\n2023-10-13 21:42:17 - de_emi - INFO - ./DS_Processing_with_CLI/ds_can_coh.zarr zarray dtype: complex64\n2023-10-13 21:42:17 - de_emi - INFO - using default parallel processing azimuth chunk size from coh dataset.\n2023-10-13 21:42:17 - de_emi - INFO - parallel processing point chunk size: 1000\n2023-10-13 21:42:17 - de_emi - INFO - starting dask CUDA local cluster.\n2023-10-13 21:42:24 - de_emi - INFO - dask local CUDA cluster started.\n2023-10-13 21:42:24 - de_emi - INFO - coh dask array shape: (740397, 17, 17)\n2023-10-13 21:42:24 - de_emi - INFO - coh dask array chunksize: (1000, 17, 17)\n2023-10-13 21:42:24 - de_emi - INFO - coh dask array dtype: complex64\n2023-10-13 21:42:24 - de_emi - INFO - phase linking with EMI.\n2023-10-13 21:42:25 - de_emi - INFO - got ph and emi_quality.\n2023-10-13 21:42:25 - de_emi - INFO - ph dask array shape: (740397, 17)\n2023-10-13 21:42:25 - de_emi - INFO - ph dask array chunksize: (1000, 17)\n2023-10-13 21:42:25 - de_emi - INFO - ph dask array dtype: complex64\n2023-10-13 21:42:25 - de_emi - INFO - emi_quality dask array shape: (740397,)\n2023-10-13 21:42:25 - de_emi - INFO - emi_quality dask array chunksize: (1000,)\n2023-10-13 21:42:25 - de_emi - INFO - emi_quality dask array dtype: float32\n2023-10-13 21:42:25 - de_emi - INFO - saving ph and emi_quality.\n2023-10-13 21:42:25 - de_emi - INFO - computing graph setted. doing all the computing.\n2023-10-13 21:42:31 - de_emi - INFO - computing finished.\n2023-10-13 21:42:33 - de_emi - INFO - dask cluster closed.\n2023-10-13 21:42:33 - de_emi - INFO - plotting emi_quality.\n2023-10-13 21:42:33 - de_emi - INFO - reading is_ds bool array\n2023-10-13 21:42:33 - de_emi - INFO - converting emi_quality from point cloud to raster.\n2023-10-13 21:42:33 - de_emi - INFO - saving figure\n2023-10-13 21:42:33 - de_emi - INFO - showing\n\n\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-13 21:42:19,594 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\n\n\n\nUnfinished…"
  },
  {
    "objectID": "Tutorials/work_with_dask.html",
    "href": "Tutorials/work_with_dask.html",
    "title": "Work With Dask",
    "section": "",
    "text": "import numpy as np\nimport zarr\nimport cupy as cp\nfrom itertools import product\n\nfrom matplotlib import pyplot as plt\nimport colorcet\n\nfrom decorrelation.shp import ks_test\nfrom decorrelation.co import emperical_co_pc\nfrom decorrelation.pl import emi\nfrom dask import array as da\nfrom dask import delayed\nimport dask\nfrom dask.distributed import Client\nfrom dask_cuda import LocalCUDACluster\ncluster = LocalCUDACluster(n_workers=2, threads_per_worker=8)\nclient = Client(cluster)\n\n2023-10-14 22:53:58,295 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-14 22:53:58,295 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n2023-10-14 22:53:58,312 - distributed.preloading - INFO - Creating preload: dask_cuda.initialize\n2023-10-14 22:53:58,312 - distributed.preloading - INFO - Import preload module: dask_cuda.initialize\n\n\nCPU times: user 362 ms, sys: 190 ms, total: 553 ms\nWall time: 3.21 s\nIn this tutorial, we demostrate how to use Dask for distributed computing.\nTwo significant issues for InSAR big data processing are: 1) the memory of CPU/GPU does not fit the volume of very big data; 2) the processing speed is limited. For the first issue, one common solution is divide the data into independent chunks and process the chunks one by one. In many case, the processing of chunks are independent. Thus the processing can be speeded up by parallel processing.\nDask is a job scheduler that allows deploying process-level parallel processing. Through the Delayed feature, Dask operations only construct the computing workflow rather than do the computation immediately. All of the computations are done at the end to allow Dask better distributing computing resources for the task. Dask makes the parallel processing easier and enable the decoupling of codes for computation and codes for scheduling.\nIn this demo, we use Dask for multi-GPU KS test to select spatially homogenious pixels. This includes:\nThe KS test is one step of DS processing, the full DS processing precedure is in the DS_processing tutorial. However, that tutorial directly utilize arrays."
  },
  {
    "objectID": "Tutorials/work_with_dask.html#processing",
    "href": "Tutorials/work_with_dask.html#processing",
    "title": "Work With Dask",
    "section": "Processing",
    "text": "Processing\nLoad data into CPU, and set the chunk size:\n\nrslc_path = '../../data/rslc.zarr'\nrslc_zarr = zarr.open(rslc_path,mode='r')\ncpu_rslc = da.from_zarr(rslc_path,chunks=(2500,1000,17))\n\n\nrslc_zarr.chunks\n\n(1000, 1000, 17)\n\n\n\nrslc_zarr.shape\n\n(2500, 1834, 17)\n\n\nNote that SHP identification requires overlapping region to correctly select brothers of pixels around the chunk bound.\n\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\n\n\ndepth = {0:az_half_win, 1:r_half_win, 2:0}; boundary = {0:'none',1:'none',2:'none'}\ncpu_rslc_overlap = da.overlap.overlap(cpu_rslc,depth=depth, boundary=boundary)\n\n\nrslc_overlap = cpu_rslc_overlap.map_blocks(cp.asarray)\nrmli_overlap = da.abs(rslc_overlap)**2\nsorted_rmli_overlap = rmli_overlap.map_blocks(cp.sort,axis=-1)\n\nDask provide a convenient function map_blocks to apply function on every chunk. However, it only support function that have only one output. Here we manually do the mapping:\n\ndelayed_ks_test = delayed(ks_test,pure=True,nout=2)\nrmli_delayed = sorted_rmli_overlap.to_delayed()\np_delayed = np.empty_like(rmli_delayed,dtype=object)\ndist_delayed = np.empty_like(rmli_delayed,dtype=object)\n\n\nwith np.nditer(p_delayed,flags=['multi_index','refs_ok'], op_flags=['readwrite']) as p_it:\n    for p_block in p_it:\n        idx = p_it.multi_index\n        dist_delayed[idx],p_delayed[idx] = delayed_ks_test(rmli_delayed[idx],az_half_win=az_half_win,r_half_win=r_half_win)\n\n        chunk_shape = (*sorted_rmli_overlap.blocks[idx].shape[:-1],az_win,r_win)\n        dtype = sorted_rmli_overlap.dtype\n        dist_delayed[idx] = da.from_delayed(dist_delayed[idx],shape=chunk_shape,meta=cp.array((),dtype=dtype))\n        p_delayed[idx] = da.from_delayed(p_delayed[idx],shape=chunk_shape,meta=cp.array((),dtype=dtype))\n\n\np = da.block(p_delayed.reshape(*p_delayed.shape,1).tolist())\ndist = da.block(dist_delayed.reshape(*dist_delayed.shape,1).tolist())\n\nAfter we get the result, the overlapping region need to be trimed:\n\ndepth = {0:az_half_win, 1:r_half_win, 2:0, 3:0}; boundary = {0:'none',1:'none',2:'none',3:'none'}\ndist = da.overlap.trim_overlap(dist,depth=depth,boundary=boundary)\np = da.overlap.trim_overlap(p,depth=depth,boundary=boundary)\n\nSelect SHPs based on p-value threshold:\n\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n\nshp_num = da.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\n\ncpu_dist = da.map_blocks(cp.asnumpy,dist)\ncpu_p = da.map_blocks(cp.asnumpy,p)\ncpu_is_shp = da.map_blocks(cp.asnumpy,is_shp)\ncpu_shp_num = da.map_blocks(cp.asnumpy,shp_num)\ncpu_is_ds_can = da.map_blocks(cp.asnumpy,is_ds_can)\n\nSave the data to disk:\n\n_cpu_dist = cpu_dist.to_zarr('dist.zarr',overwrite=True,compute=False)\n_cpu_p = cpu_p.to_zarr('p.zarr',overwrite=True,compute=False)\n\nDo the computation:\n\nshp_num_result, is_ds_can_result = da.compute(_cpu_dist,_cpu_p,cpu_shp_num,cpu_is_ds_can)[2:]\n\nCPU times: user 286 ms, sys: 243 ms, total: 529 ms\nWall time: 7.48 s\n\n\n\ncluster.close()\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(shp_num_result,cmap=colorcet.cm.fire)\nax.set(title='Number of SHPs',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(is_ds_can_result,cmap=colorcet.cm.fire)\nax.set(title='DS Candidate distribution',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()\n\n\n\n\n\nimport numpy as np\nimport zarr\nimport cupy as cp\nfrom decorrelation.shp import ks_test\nrslc_zarr = zarr.open('../../data/rslc.zarr',mode='r')\nrslc_cpu = rslc_zarr[:]\nrslc = cp.asarray(rslc_cpu)\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\naz_half_win = 5\nr_half_win = 5\naz_win = 2*az_half_win+1\nr_win = 2*r_half_win+1\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\ndist_cpu = cp.asnumpy(dist)\np_cpu = cp.asnumpy(p)\nzarr.save_array('dist_ks.zarr', dist_cpu,chunks=(1000,1000,az_win,r_win),compressor=None)\nzarr.save_array('p_ks.zarr', p_cpu,chunks=(1000,1000,az_win,r_win),compressor=None)\n\nCPU times: user 1.22 s, sys: 6.36 s, total: 7.58 s\nWall time: 7.69 s"
  },
  {
    "objectID": "API/plot.html",
    "href": "API/plot.html",
    "title": "Plot",
    "section": "",
    "text": "source\n\nbg_alpha\n\n bg_alpha (pwr)"
  },
  {
    "objectID": "API/pl.html",
    "href": "API/pl.html",
    "title": "pl",
    "section": "",
    "text": "Code for generating data for test and doc\nimport cupy as cp\nimport numpy as np\nimport zarr\nimport h5py\nfrom decorrelation.shp import ks_test\nfrom decorrelation.co import emperical_co,emperical_co_pc, regularize_spectral\n\nfrom matplotlib import pyplot as plt"
  },
  {
    "objectID": "API/pl.html#emi",
    "href": "API/pl.html#emi",
    "title": "pl",
    "section": "EMI",
    "text": "EMI\n\nsource\n\nemi\n\n emi (coh:cupy.ndarray, ref:int=0)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix,dtype cupy.complex\n\n\nref\nint\n0\nindex of reference image in the phase history output, optional. Default: 0\n\n\nReturns\ntuple\n\nestimated phase history ph, dtype complex; quality (minimum eigvalue, dtype float)\n\n\n\nemi is a phase estimator base on Eigendecomposition-based Maximum-likelihood-estimator of Interferometric phase (EMI) (Ansari, De Zan, and Bamler 2018) phase linking method.\nThe amplitude of coh should range between 0 and 1 and the phase of coh should be the interferometric phase. The returned phase is also complex but the amplitude is setted to 1. The quality factor is a measure for the inadequacy of EMI’s model that adding real-valued dyadic for calibration of real coherence matrix which is generally poorly estimated. It is supposed to larger than 1 and smaller means better.\nExample: Complex coherence matrix from a stack of 17 SLC images:\n\n\nCode for generating data for test and doc\nrslc = zarr.open('../../data/rslc.zarr/','r')\nrslc = cp.asarray(rslc[:])\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndel rmli\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\ndel p\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\n\n\n\nds_can_coh.shape\n\n(740397, 17, 17)\n\n\n\nds_can_ph, ds_can_emi_quality = emi(ds_can_coh)\nds_can_ph.shape, ds_can_emi_quality.shape\n\n((740397, 17), (740397,))\n\n\n\ncp.angle(ds_can_ph[:,0])\n\narray([-1.12013545e-08,  1.89226612e-09,  1.36733591e-09, ...,\n       -4.15640944e-09, -1.74935986e-11, -3.61503560e-09], dtype=float32)\n\n\n\nds_can_emi_quality_2d = cp.empty_like(is_ds_can,dtype=ds_can_emi_quality.dtype)\nds_can_emi_quality_2d[:] = cp.nan\nds_can_emi_quality_2d[is_ds_can] = ds_can_emi_quality\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_emi_quality_2d),interpolation='nearest',vmin=1,vmax=1.3)\nax.set(title='DS EMI quality factor',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "href": "API/pl.html#temporal-coherence-for-distributed-scatterer",
    "title": "pl",
    "section": "Temporal Coherence for Distributed Scatterer",
    "text": "Temporal Coherence for Distributed Scatterer\n\nsource\n\ntemp_coh\n\n temp_coh (coh:cupy.ndarray, ds_ph=&lt;class 'cupy.ndarray'&gt;)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoh\nndarray\n\ncomplex coherence metrix, dtype cupy.complex\n\n\nds_ph\ntype\nndarray\ncomplex phase history, dtype cupy.complex\n\n\n\nThis function estimate the temporal coherence of DSs which is defined as (Ferretti et al. 2011):\n\\[\\gamma = \\frac{1}{N^2-N} \\sum_{n=1}^{N} \\sum_{k \\neq n}^{N} e^{i\\phi_{nk}} e^{-i(\\theta_n-\\theta_k)}\\]\nWhere \\(\\phi_{nk}\\) is the phase of complex coherence matrix and \\(\\theta_{n}\\) is the phase after phase linking.\n\n\nCode for generating data for test and doc\nrslc = zarr.open('../../data/rslc.zarr/','r')\nrslc = cp.asarray(rslc[:])\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndel rmli\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\n\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)\nds_can_ph = emi(ds_can_coh)[0]\n\n\n\nds_can_coh.shape,ds_can_ph.shape\n\n((740397, 17, 17), (740397, 17))\n\n\n\nds_can_temp_coh = temp_coh(ds_can_coh,ds_can_ph)\nds_can_temp_coh.shape\n\n(740397,)\n\n\n\nds_can_temp_coh_2d = cp.empty_like(is_ds_can,dtype=ds_can_temp_coh.dtype)\nds_can_temp_coh_2d[:] = cp.nan\nds_can_temp_coh_2d[is_ds_can] = ds_can_temp_coh\n\n\nfig, ax = plt.subplots(1,1,figsize=(10,10))\npcm = ax.imshow(cp.asnumpy(ds_can_temp_coh_2d),interpolation='nearest')\nax.set(title='DS Temporal Coherence',xlabel='Range Index',ylabel='Azimuth Index')\nfig.colorbar(pcm)\nfig.show()"
  },
  {
    "objectID": "API/pc.html",
    "href": "API/pc.html",
    "title": "pc",
    "section": "",
    "text": "The indices of point cloud data idx is expressed as sorted int32 array with shape (2, n_point).\nidx[0,:] is their azimuth indices and idx[1,:] is the range indices.\nidx is first sorted in azimuth indices and then sorted in range indices.\nHere is an example:\narray([[0, 0, 1, 1, 2, 3],\n       [2, 3, 0, 3, 1, 2]], dtype=int32)\n\nsource\n\npc2ras\n\n pc2ras (idx:Union[numpy.ndarray,cupy.ndarray],\n         pc_data:Union[numpy.ndarray,cupy.ndarray], shape:tuple)\n\nconvert sparse data to raster, filled with nan\n\n\n\n\nType\nDetails\n\n\n\n\nidx\nUnion\nidx array\n\n\npc_data\nUnion\ndata, 1D or more\n\n\nshape\ntuple\nimage shape\n\n\n\n\nsource\n\n\npc_union\n\n pc_union (idx1:Union[numpy.ndarray,cupy.ndarray],\n           idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the union of two point cloud dataset. For points at their intersection, pc_data1 rather than pc_data2 is copied to the result pc_data.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe union index idx; index of the point in output union index that originally in the first point cloud inv_iidx; index of the point in output union index that only exist in the second point cloud inv_iidx2; index of the point in the second input index that are not in the first input point cloud\n\n\n\nUsage:\n\nras = cp.array([[4,3,8,3],\n                [4,7,2,6],\n                [9,0,3,7],\n                [1,4,2,6]])\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\npc_data1 = cp.array([3,2,5,4,32,2])\npc_data2 = cp.array([3,5,6,2,1,4])\n\nidx, inv_iidx1, inv_iidx2, iidx2 = pc_union(idx1,idx2)\n\nWith all the returns in pc_union, it is very easy to construct the union data:\n\npc_data = cp.empty((idx.shape[1],*pc_data1.shape[1:]),dtype=pc_data1.dtype)\npc_data[inv_iidx1] = pc_data1\npc_data[inv_iidx2] = pc_data2[iidx2]\n\nnp.testing.assert_equal(cp.asnumpy(pc_data),np.array([3,3,2,5,6,4,32,1,4,2]))\nnp.testing.assert_equal(cp.asnumpy(ras[idx[0],idx[1]]),np.array([4,8,3,4,7,6,0,7,4,2]))\n\n\nsource\n\n\npc_intersect\n\n pc_intersect (idx1:Union[numpy.ndarray,cupy.ndarray],\n               idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the intersection of two point cloud dataset.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe intersect index idx,index of the point in first point cloud index that also exist in the second point cloud,index of the point in second point cloud index that also exist in the first point cloud\n\n\n\n\nras = cp.array([[4,3,8,3],\n                [4,7,2,6],\n                [9,0,3,7],\n                [1,4,2,6]])\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\npc_data1 = cp.array([3,2,5,4,32,2])\npc_data2 = cp.array([3,5,6,2,1,4])\n\nidx, iidx1, iidx2 = pc_intersect(idx1,idx2)\npc_data_int1 = pc_data1[iidx1]\npc_data_int2 = pc_data2[iidx2]\n\nnp.testing.assert_equal(cp.asnumpy(idx),np.array([[0,2],\n                                                  [3,1]]))\nnp.testing.assert_equal(cp.asnumpy(ras[(idx[0],idx[1])]),np.array([3,0]))\nnp.testing.assert_equal(cp.asnumpy(pc_data_int1),np.array([2,32]))\nnp.testing.assert_equal(cp.asnumpy(pc_data_int2),np.array([5,2]))\n\n\nsource\n\n\npc_diff\n\n pc_diff (idx1:Union[numpy.ndarray,cupy.ndarray],\n          idx2:Union[numpy.ndarray,cupy.ndarray])\n\nGet the point cloud in idx1 that are not in idx2.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nidx1\nUnion\nint array, index of the first point cloud\n\n\nidx2\nUnion\nint array, index of the second point cloud\n\n\nReturns\ntuple\nthe diff index idx,index of the point in first point cloud index that do not exist in the second point cloud,\n\n\n\n\nidx1 = cp.array([[0,0,1,1,2,3],\n                 [2,3,0,3,1,2]],dtype=np.int32)\nidx2 = cp.array([[0,0,1,2,2,3],\n                 [0,3,1,1,3,1]],dtype=np.int32)\n\nidx, iidx1 = pc_diff(idx1,idx2)\npc_data_diff = pc_data1[iidx1]\n\nnp.testing.assert_equal(cp.asnumpy(idx),np.array([[0,1,1,3],\n                                                  [2,0,3,2]]))\nnp.testing.assert_equal(cp.asnumpy(iidx1),np.array([0,2,3,5]))"
  },
  {
    "objectID": "API/co.html",
    "href": "API/co.html",
    "title": "co",
    "section": "",
    "text": "For generating data for doc and test\nimport cupy as cp\nimport zarr\nfrom decorrelation.shp import ks_test\nimport math\nimport itertools\nfrom cupy.testing import assert_array_almost_equal"
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-estimator",
    "href": "API/co.html#covariance-and-coherence-matrix-estimator",
    "title": "co",
    "section": "Covariance and Coherence Matrix Estimator",
    "text": "Covariance and Coherence Matrix Estimator\n\nsource\n\nemperical_co\n\n emperical_co (rslc:cupy.ndarray, is_shp:cupy.ndarray, block_size:int=128)\n\nMaximum likelihood covariance estimator.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: cupy.complexfloating\n\n\nis_shp\nndarray\n\nshp bool, dtype: cupy.bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe covariance and coherence matrix cov and coh\n\n\n\nThe cov and coh is defined as:\n\\[\ncov = E(z_1z_2^*) \\quad coh=\\frac{E(z_1z_2^*)}{\\sqrt{E(|z_1|^2)E(|z_2|^2)}}\n\\]\nand estimated as:\n\\[\ncov = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{L} \\quad coh = \\frac{\\sum_{i=1}^{L}z_1^{i}z_2^{i*}}{\\sqrt(\\sum_{i=1}^{L}|z_1^{i}|^2)(\\sum_{i=1}^{L}|z_2^{i}|^2)}\n\\]\nusing all selected SHPs. Their shapes are [nlines,width,nimages,nimages].\nThe rslc is a three dimentional cupy ndarray. The dtype should be cupy.complex64. From outerest to innerest, the three dimentions are azimuth, range and image. is_shp is a four dimentional cupy ndarray. It describes if pixels in the search window are SHP to the central pixel. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range.\nHere is an example:\n\n\nFor generating data for doc and test\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\n\n\n\nrslc.shape, is_shp.shape, is_shp[2,3]\n\n((5, 10, 17),\n (5, 10, 3, 5),\n array([[False, False, False, False,  True],\n        [False, False,  True, False, False],\n        [False, False,  True, False, False]]))\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. It shows for pixel (2,3), the (3*5) window around it has 2 SHPs to it (the central one is itself).\n\ncov,coh = emperical_co(rslc,is_shp)\ncov.shape, coh.shape\n\n((5, 10, 17, 17), (5, 10, 17, 17))\n\n\nBoth cov and coh are complex data. The shape shows each covarience or coherence matrix is 17 by 17 since there are 17 images. And cov and coh are matrix for all 5*10 pixels.\n\nsource\n\n\nemperical_co_pc\n\n emperical_co_pc (rslc:cupy.ndarray, idx:cupy.ndarray,\n                  pc_is_shp:cupy.ndarray, block_size:int=128)\n\nMaximum likelihood covariance estimator for sparse data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrslc\nndarray\n\nrslc stack, dtype: cupy.complexfloating\n\n\nidx\nndarray\n\nindex of point target (azimuth_index, range_index), dtype: cupy.int, shape: (2,n_sp)\n\n\npc_is_shp\nndarray\n\nshp bool, dtype: cupy.bool\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe covariance and coherence matrix cov and coh\n\n\n\nemperical_co_sp is the emperical_co on sparse data, e.g., DSs. rslc is same as emperical_co. sp_idx is the index, i.e., a tuple of (azimuth_idx, range_idx). Each index is 1D array. pc_is_shp is similar to is_shp in emperical_co but it only contains information about the point cloud data. It is a 3D array with shape [number_of_point,az_win,r_win].\nCompared with emperical_co, emperical_co_pc only estimate coherence/covariance at specific position so the memory usage is much small.\nExample:\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 3\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.stack(cp.where(is_ds_can))\n\n\n\nrslc.shape,ds_can_idx,ds_can_is_shp\n\n((5, 10, 17),\n array([[2, 3, 3, 4, 4],\n        [3, 3, 5, 1, 4]]),\n array([[[False, False, False, False,  True],\n         [False, False,  True, False, False],\n         [False, False,  True, False, False]],\n \n        [[False, False,  True, False, False],\n         [False, False,  True, False, False],\n         [False, False, False,  True, False]],\n \n        [[False, False, False, False, False],\n         [False, False,  True, False, False],\n         [ True,  True, False, False, False]],\n \n        [[False, False,  True, False, False],\n         [False,  True,  True, False, False],\n         [False, False, False, False, False]],\n \n        [[False,  True,  True,  True, False],\n         [False, False,  True, False,  True],\n         [False, False, False, False, False]]]))\n\n\nrslc is a stack of 17 rslc images. Each of the image has 5 pixel in azimuth dimention and 10 pixels in range dimention. ds_can_idx shows the index of the DS candidates and ds_can_is_shp shows the corrosponding SHPs.\n\nds_can_cov, ds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)"
  },
  {
    "objectID": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "href": "API/co.html#covariance-and-coherence-matrix-regularizer",
    "title": "co",
    "section": "Covariance and Coherence Matrix Regularizer",
    "text": "Covariance and Coherence Matrix Regularizer\n\nsource\n\nisPD\n\n isPD (co:cupy.ndarray)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nabsolute value of complex coherence/covariance stack\n\n\nReturns\nndarray\nbool array indicating wheather coherence/covariance is positive define\n\n\n\nThis function tells if the matrix is positive defined or not.\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:650,600:650]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 5; r_half_win = 5\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\n# Select DS candidate\nshp_num = cp.count_nonzero(is_shp,axis=(-2,-1))\nis_ds_can = shp_num &gt;= 50\nds_can_is_shp = is_shp[is_ds_can]\nds_can_idx = cp.where(is_ds_can)\n\nds_can_coh = emperical_co_pc(rslc,ds_can_idx,ds_can_is_shp)[1]\n\n\n\nds_can_coh.shape\n\n(149, 17, 17)\n\n\n\nisPD_ds_can = isPD(ds_can_coh)\n\n\nisPD_ds_can\n\narray([ True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True,  True,  True,  True,  True,\n        True,  True,  True,  True,  True])\n\n\nAll coherence matrix are positive defined.\n\nsource\n\n\nnearestPD\n\n nearestPD (co:cupy.ndarray)\n\nFind the nearest positive-definite matrix to input matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nco\nndarray\nstack of matrix with shape […,N,N]\n\n\nReturns\nndarray\nnearest positive definite matrix of input, shape […,N,N]\n\n\n\nnearest means the Frobenius norm of the difference is minimized.\n\nsource\n\n\nregularize_spectral\n\n regularize_spectral (coh:cupy.ndarray, beta:Union[float,cupy.ndarray])\n\nSpectral regularizer for coherence matrix.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncoh\nndarray\nstack of matrix with shape […,N,N]\n\n\nbeta\nUnion\nthe regularization parameter, a float number or cupy ndarray with shape […]\n\n\nReturns\nndarray\nregularized matrix, shape […,N,N]\n\n\n\nregularize_spectral can regularize the absolute value of coherence matrix for better phase linking. It is first presented in (Zwieback 2022).\nExamples:\n\n\nCode for generating data for doc\nrslc = zarr.open('../../data/rslc.zarr/','r')[600:605,600:610]\nrslc = cp.asarray(rslc)\n\n# SHP selection\naz_half_win = 1; r_half_win = 2\naz_win = 2*az_half_win+1; r_win = 2*r_half_win+1\n\nrmli = cp.abs(rslc)**2\nsorted_rmli = cp.sort(rmli,axis=-1)\ndist,p = ks_test(sorted_rmli,az_half_win=az_half_win,r_half_win=r_half_win)\nis_shp = (p &lt; 0.05) & (p &gt;= 0.0)\n\ncov,coh = emperical_co(rslc,is_shp)\n\n\n\ncoh.shape\n\n(5, 10, 17, 17)\n\n\n\nregularized_coh1 = regularize_spectral(coh,0.1)\n\nMore general, bata can be a cp.ndarray:\n\nbeta = cp.ones(coh.shape[:-2])/10\nregularized_coh2 = regularize_spectral(coh,beta)"
  },
  {
    "objectID": "API/shp.html",
    "href": "API/shp.html",
    "title": "shp",
    "section": "",
    "text": "from scipy import stats\nimport numpy as np\nimport itertools"
  },
  {
    "objectID": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "href": "API/shp.html#kolmogorov-smirnov-ks-two-sample-test",
    "title": "shp",
    "section": "Kolmogorov-Smirnov (KS) two-sample test",
    "text": "Kolmogorov-Smirnov (KS) two-sample test\n\nsource\n\nks_test\n\n ks_test (rmli:cupy.ndarray, az_half_win:int, r_half_win:int,\n          block_size:int=128)\n\nSHP identification based on Two-Sample Kolmogorov-Smirnov Test.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrmli\nndarray\n\nthe rmli stack, dtype: cupy.floating\n\n\naz_half_win\nint\n\nSHP identification half search window size in azimuth direction\n\n\nr_half_win\nint\n\nSHP identification half search window size in range direction\n\n\nblock_size\nint\n128\nthe CUDA block size, it only affects the calculation speed\n\n\nReturns\ntuple\n\nthe KS test statistics dist and p value p\n\n\n\nThe ks_test function apply the Two-Sample Kolmogorov-Smirnov Test on a stack of rmli images to identify SHPs candidate for further processing. This method is originally published in (Ferretti et al. 2011). This function is designed to run on GPU for high speed.\nThe rmli is a three dimentional cupy ndarray. The dtype should be float. From outerest to innerest, the three dimentions are azimuth, range and image. For each pixel P, a search window centered at P is defined by az_half_win and r_half_win. All pixels in this search window is compared with P by KS test. They are refered here as secondary pixels. The total number of secondary pixels (including P) is (2*az_half_win+1)*(2*r_half_win+1).\nThe returns are the ks test statistic which is the maximum value of the absolute difference between the emperical cumulative distribution functions of the two samples, and p value. Both of them are 4 dimentional cupy ndarrays. From outerest ot innerest, they are azimuth, range, secondary pixel relative azimuth, secondary pixel relative range. For P at the corner of the image where part of the search window is out of the image, the result is -1.\nHere is a simplest example. First simulate rmli time series of two pixels from two correlated normal distributions:\n\nsample_size = 20\nrng = np.random.default_rng()\nsample1 = stats.uniform.rvs(size=sample_size, random_state=rng).astype(cp.float32)\nsample2 = stats.norm.rvs(size=sample_size, random_state=rng).astype(cp.float32)\n\nConvert the data to cupy ndarray and make sure the dtype is cp.float32 and the data are sorted:\n\nrmli_stack = cp.stack((cp.asarray(sample1), cp.asarray(sample2))).reshape(1,2,sample_size)\nrmli_stack = rmli_stack.astype(cp.float32)\nrmli_stack.shape\n\n(1, 2, 20)\n\n\nThe shape of rmli_stack shows it contains 20 images. Each of the image has 1 pixel in azimuth dimention and 2 pixels in range dimention. Set the az_half_win and r_half_win to 1 and apply the ks_test function:\n\ndist,p = ks_test(rmli_stack,1,1)\nprint(dist.shape)\nprint(dist)\n\n(1, 2, 3, 3)\n[[[[-1.  -1.  -1. ]\n   [-1.   0.   0.6]\n   [-1.  -1.  -1. ]]\n\n  [[-1.  -1.  -1. ]\n   [ 0.6  0.  -1. ]\n   [-1.  -1.  -1. ]]]]\n\n\ndist is the ks test statistic. The shape of it shows for each pixel P in this 1*2 image, a 3*3 search window is defined and all pixels in this search window is test with P. The value 0 in dist is the ks test result of pixel P and pixel P itself. The value -1 means the secondary pixel is out of the image and no ks test is applied.\n\nprint(p.shape)\nprint(p)\n\n(1, 2, 3, 3)\n[[[[-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]\n   [-1.0000000e+00  0.0000000e+00  7.2528544e-04]\n   [-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]]\n\n  [[-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]\n   [ 7.2528544e-04  0.0000000e+00 -1.0000000e+00]\n   [-1.0000000e+00 -1.0000000e+00 -1.0000000e+00]]]]\n\n\np is the ks test p value with same shape of dist.\n\nprint(stats.ks_2samp(sample1, sample2,method='asymp'))\n\nKstestResult(statistic=0.6, pvalue=0.0005681672000000003, statistic_location=-0.12029845, statistic_sign=-1)\n\n\nBy comparing the result of ks_test and ks_2samp from scipy, the statistics are same which prove the correctness of ks_test. The difference in p value is because the approcimation method used are different but the orders of magnitudes are consistent."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Decorrelation",
    "section": "",
    "text": "A InSAR postprocessing tool in big data era\nThis package provide functions for InSAR post-processing which refers as processing after SAR images co-registration and geocoding. The functions include PS/DS identification, coherence matrix estimation, phase linking etc."
  },
  {
    "objectID": "index.html#what-make-decorrelation-different",
    "href": "index.html#what-make-decorrelation-different",
    "title": "Decorrelation",
    "section": "What make Decorrelation different?",
    "text": "What make Decorrelation different?\n\nDecorrelation implements state-of-art InSAR techniques. Currently it includes advanced PS/DS identification, phase linking and deep-learning-based methods that performs much better than the classic one.\nDecorrelation runs fast. As many of InSAR processing are pixel-wise or patch-wise manipulation, Most of Decorrelation functions are implemented with well-optimized GPU code. Furthermore, with the support of Dask, Decorrelation can be runed on multi-GPUs to further accelerate the processing and get rid of the limitation of GPU memory.\nDecorrelation support interative big data visulization. Since the SAR data volume increase dramatically recently and in near future, not only the processing time is a concern (which is largely solved as Decorrelation runs so fast!), the inspection on the images is a problem. Decorrelation provide Datashader-based functions for accurate, interative representation on even largest time series InSAR data.\n\nPlease refer to the Documentation for detailed usage.\nWarning!!! Due to the heavy dependence on CUDA, this package only works on device with Nivida GPU.\nWarning!!! This package is under intensive development. API is subjected to change without any noticement."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Decorrelation",
    "section": "Install",
    "text": "Install\nBecause of GPU driver and CUDA Version Compatibility, there is no simple solution for CUDA related packages installation. Users need to successfully install cupy and dask_cuda first.\nHere is some tips for installing them. Generally, the cuda driver is alrealy installed and maintained by the system administrator. Users only need to determine the right cudatoolkit version. Frist run\nnvidia-smi\nIt will prints something like:\n...\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 525.105.17   Driver Version: 525.105.17   CUDA Version: 12.0     |\n|-------------------------------+----------------------+----------------------+\n...\nThe CUDA Version is the maxminum cudatoolkit version that supported by the current CUDA driver. Here we use version 11.8 as an example. Then you can install the needed cudatoolkit, cupy, dask_cuda by:\nconda install -c \"nvidia/label/cuda-11.8.0\" cuda-toolkit\nconda install -c conda-forge cupy cuda-version=11.8\nconda install -c rapidsai -c conda-forge -c nvidia dask-cuda cuda-version=11.8\nThen\nWith conda:\nconda install -c conda-forge decorrelation\nOr with pip:\npip install decorrelation\nIn development mode:\ngit clone git@github.com:kanglcn/decorrelation.git ./decorrelation\ncd ./decorrelation\npip install -e '.[dev]'"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Decorrelation",
    "section": "How to use",
    "text": "How to use\nRead the software architecture first."
  },
  {
    "objectID": "index.html#contact-us",
    "href": "index.html#contact-us",
    "title": "Decorrelation",
    "section": "Contact us",
    "text": "Contact us\n\nMost discussion happens on GitHub. Feel free to open an issue or comment on any open issue or pull request.\nuse github discussions to ask questions or leave comments."
  },
  {
    "objectID": "index.html#contribution",
    "href": "index.html#contribution",
    "title": "Decorrelation",
    "section": "Contribution",
    "text": "Contribution\n\nPull requests are welcomed! Before making a pull request, please open an issue to talk about it.\nWe have notice many excellent open-source packages are rarely paid attention to due to lack of documentation. The package is developed with the nbdev, a notebook-driven development platform. Developers only need to simply write notebooks with lightweight markup and get high-quality documentation, tests, continuous integration, and packaging automatically."
  }
]