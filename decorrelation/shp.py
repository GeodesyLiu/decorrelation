# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/shp.ipynb.

# %% auto 0
__all__ = ['searchsorted', 'ecdf_distance', 'ks_2sam']

# %% ../nbs/api/shp.ipynb 4
import cupy as cp
#from cupy._sorting.search import _searchsorted_kernel as searchsorted

# %% ../nbs/api/shp.ipynb 6
def searchsorted(ref:cp.ndarray, # multi dimentional array
                   sec:cp.ndarray, # multi dimentional array
                  )->cp.ndarray: # multi dimentional index array, dtype: cp.int
    innerest_dim = ref.shape[-1]
    outer_dim = ref.shape[:-1]
    max_num = cp.maximum(ref.max()-ref.min(),sec.max()-sec.min())+1
    multiple = cp.expand_dims(cp.arange(ref.size/innerest_dim,dtype=int).reshape(*outer_dim),axis=-1)
    added = max_num*multiple
    # test have show that ref.max() is faster than ref[:,-1].max() when ref.shape[1] is less than 100
    p = cp.searchsorted((ref+added).ravel(),(sec+added).ravel(),side='right').reshape(*sec.shape)
    return p - innerest_dim*(multiple)

# %% ../nbs/api/shp.ipynb 16
def ecdf_distance(data1:cp.ndarray, # data set 1
                  data2, # data set 2
                  n:int=0, # number of dimensions to compare
                 ):
    n = data1.shape[-1]
    data_all = cp.concatenate((data1,data2),axis=-1)
    cdf1 = searchsorted(data1,data_all)/n
    cdf2 = searchsorted(data2,data_all)/n
    cddiffs = cp.abs(cdf1 - cdf2)
    distance = cp.max(cddiffs,axis=-1)
    return distance

# %% ../nbs/api/shp.ipynb 22
def ks_2sam(data1:cp.ndarray, # samples to be test, each innermost vector is samples from one distribution
            data2:cp.ndarray, # the seconds stack of samples,
            alpha:float=0.9, # significant value, the bigger the stricter in selecting SHP, between 0 and 1
           ) -> cp.array: # stack of bool, if SHP or not
    '''GPU version of ks 2 sample test'''
    # null: same distribution
    distance = ecdf_distance(data1,data2)
    from scipy.stats import kstwo
    critical_distance = kstwo.ppf(1-alpha,data1.shape[-1])
    return distance < critical_distance
